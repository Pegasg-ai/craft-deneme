<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <title>Voxel Velocity - Final</title>
    <style>
        :root {
            --ui-font: 'Segoe UI', sans-serif;

            --ui-overlay: rgba(15, 20, 30, 0.78);
            --ui-panel: #222f3e;
            --ui-panel-2: #2f3640;
            --ui-panel-3: #353b48;
            --ui-border: #576574;

            --ui-text: #c8d6e5;
            --ui-muted: #8395a7;
            --ui-accent: #48dbfb;

            --ui-green: #10ac84;
            --ui-blue: #2e86de;
            --ui-orange: #ff9f43;
            --ui-grey: #57606f;

            --ui-radius-lg: 16px;
            --ui-radius-md: 12px;
            --ui-radius-sm: 10px;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: var(--ui-font);
            background-color: #5D8AA8;
            user-select: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 6px;
            pointer-events: none;
            font-size: 14px;
        }

        /* HOTBAR */
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .slot {
            width: 50px;
            height: 50px;
            border: 2px solid #555;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: 0.1s;
            border-radius: 4px;
        }

        .slot.active {
            border-color: white;
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .slot-color {
            width: 30px;
            height: 30px;
            border-radius: 2px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* MENU */
        #menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
                        background:
                                radial-gradient(1200px 800px at 50% 18%, rgba(72, 219, 251, 0.12), rgba(0, 0, 0, 0) 62%),
                                var(--ui-overlay);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
                        padding: 16px;
                        box-sizing: border-box;
                        backdrop-filter: blur(10px);
                        -webkit-backdrop-filter: blur(10px);
        }

        .menu-frame {
                        background:
                                linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02)),
                                var(--ui-panel);
                        width: min(620px, 94vw);
                        max-height: min(620px, 84vh);
                        border-radius: var(--ui-radius-lg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
                        box-shadow: 0 22px 70px rgba(0, 0, 0, 0.78);
                        border: 1px solid rgba(255, 255, 255, 0.10);
        }

        .tabs {
            display: flex;
                        background: rgba(255, 255, 255, 0.04);
                        border: 1px solid rgba(255, 255, 255, 0.08);
                        padding: 8px;
                        gap: 8px;
                        margin: 16px 16px 0 16px;
                        border-radius: var(--ui-radius-md);
        }

        .tab {
            flex: 1;
                        padding: 12px 10px;
            text-align: center;
            cursor: pointer;
                        color: rgba(200, 214, 229, 0.75);
                        font-weight: 800;
                        letter-spacing: 0.4px;
                        font-size: 13px;
                        transition: 0.15s;
                        border-radius: var(--ui-radius-sm);
                        user-select: none;
                        border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .tab.active {
                        background: rgba(72, 219, 251, 0.14);
                        color: white;
                        border-color: rgba(72, 219, 251, 0.35);
                        box-shadow:
                                0 10px 26px rgba(0, 0, 0, 0.28),
                                inset 0 0 0 1px rgba(72, 219, 251, 0.18);
        }

        .tab:hover {
                        background: rgba(255, 255, 255, 0.06);
        }

        .content {
                        padding: 18px 18px 0 18px;
            flex: 1;
            display: none;
                        overflow: auto;
        }

        .content.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: rgba(200, 214, 229, 0.92);
            font-weight: 600;
            font-size: 13px;
        }

        input,
        select {
            width: 100%;
            padding: 12px 12px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.10);
            color: white;
            border-radius: var(--ui-radius-sm);
            box-sizing: border-box;
            outline: none;
            font-size: 15px;
        }

        input::placeholder {
            color: rgba(200, 214, 229, 0.55);
        }

        input:focus,
        select:focus {
            border-color: rgba(72, 219, 251, 0.6);
            box-shadow: 0 0 0 3px rgba(72, 219, 251, 0.18);
            background: rgba(255, 255, 255, 0.075);
        }

        select {
            cursor: pointer;
        }

        input[type="color"] {
            cursor: pointer;
            height: 46px;
            padding: 6px;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 2px;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 1px solid #576574;
            border-radius: 4px;
        }

        .btn-row {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        button {
            flex: 1;
            padding: 13px 14px;
            border: none;
            border-radius: 14px;
            font-weight: bold;
            cursor: pointer;
            color: white;
            font-size: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: 0.15s;
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.25);
        }

            button:focus-visible {
                outline: 2px solid var(--ui-accent);
                outline-offset: 2px;
            }

        .btn-green {
            background: var(--ui-green);
        }

        .btn-green:hover {
            background: #1dd1a1;
        }

        .btn-blue {
            background: var(--ui-blue);
        }

        .btn-blue:hover {
            background: #54a0ff;
        }

        .btn-orange {
            background: var(--ui-orange);
        }

        .btn-orange:hover {
            background: #ffaf40;
        }

        #btn-close-menu {
            margin: 16px;
            text-align: center;
            background: rgba(255, 255, 255, 0.04);
            color: rgba(200, 214, 229, 0.9);
            padding: 12px;
            border-radius: 14px;
            font-weight: bold;
            cursor: pointer;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.10);
            user-select: none;
        }

        #btn-close-menu:hover {
            background: rgba(255, 255, 255, 0.07);
        }

        #status {
            color: #fbc531;
            font-size: 13px;
            margin-top: 15px;
            text-align: center;
        }

        .help-box {
            margin-top: 15px;
            padding: 14px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 14px;
            font-size: 13px;
            color: rgba(200, 214, 229, 0.92);
            line-height: 1.35;
        }

        .help-box strong {
            color: white;
        }

        #loading {
            position: absolute;
            bottom: 5px;
            right: 5px;
            color: #555;
            font-size: 10px;
        }
    </style>
</head>

<body>
    <div id="crosshair"></div>
    <div id="hud">
        FPS: <span id="fps">0</span> | Blok: <span id="blk">0</span><br>
        <span style="color:#aaa; font-size:12px">L: Kır | R: Koy | Orta: Seç | E: Envanter | F: Araç | Shift: Koş</span>
    </div>

    <div id="hotbar"></div>

    <div id="menu-overlay" style="display: flex;">
        <div class="menu-frame">
            <div class="tabs">
                <div class="tab active" data-tab="settings">ANA MENÜ</div>
                <div class="tab" data-tab="graphics">GRAFİK</div>
                <div class="tab" data-tab="multiplayer">ÇOK OYUNCULU</div>
            </div>

            <!-- Settings -->
            <div id="settings" class="content active">
                <div class="control-group">
                    <label>Oyuncu İsmi</label>
                    <input type="text" id="inp-nick" value="Oyuncu" maxlength="20">
                </div>
                <div class="control-group">
                    <label>Karakter Rengi</label>
                    <input type="color" id="inp-color" value="#00a8ff">
                </div>

                <div class="btn-row">
                        <button class="btn-orange" id="btn-single">OYUNA BAŞLA</button>
                </div>
            </div>

            <!-- Graphics Settings -->
            <div id="graphics" class="content">
                <div class="control-group">
                    <label>Grafik Kalitesi</label>
                        <select id="quality-select">
                        <option value="high">YÜKSEK (Güzel Görünüm)</option>
                        <option value="medium">ORTA (Dengeli)</option>
                        <option value="low">DÜŞÜK (Performans)</option>
                    </select>
                </div>
                    <div class="help-box">
                    <strong>DÜŞÜK:</strong> Render mesafesi azalır, daha az detay, daha yüksek FPS<br>
                    <strong>ORTA:</strong> Dengeli performans ve görsel kalite<br>
                    <strong>YÜKSEK:</strong> En iyi görünüm, daha fazla GPU kullanımı
                </div>
            </div>

            <!-- Multiplayer -->
            <div id="multiplayer" class="content">
                <div class="control-group">
                    <label>Senin ID No</label>
                    <input type="text" id="my-id" readonly onclick="this.select()"
                        style="background:#222; text-align:center; letter-spacing:1px;">
                </div>
                <div class="control-group">
                    <label>Arkadaş ID No</label>
                    <input type="text" id="host-id" placeholder="ID Yapıştır">
                </div>
                <div class="btn-row">
                    <button class="btn-green" id="btn-host">SUNUCU OL</button>
                    <button class="btn-blue" id="btn-join">BAĞLAN</button>
                </div>
                <p id="status"></p>
            </div>

            <div id="btn-close-menu">MENÜYÜ KAPAT (ESC)</div>
        </div>
        <div id="loading">VoxelEngine v1.1</div>
    </div>

    <!-- LIB (bundled for Tauri/offline) -->
    <script src="./vendor/three.min.js"></script>
    <script src="./vendor/PointerLockControls.js"></script>
    <script src="./vendor/peerjs.min.js"></script>
    <script src="./js/noise.js"></script>
    
    <!-- Game Modules -->
    <script src="./js/blocks.js"></script>
    <script src="./js/biomes.js"></script>
    <script src="./js/trees.js"></script>
    <script src="./js/ores.js"></script>
    <script src="./js/crafting.js"></script>
    <script src="./js/mobs.js"></script>
    <script src="./js/plants.js"></script>
    <script src="./js/chunk.js"></script>
    <script src="./js/vehicle.js"></script>
    <script src="./js/inventory.js"></script>

    <script>
        // --- PRE-INIT GLOBALS ---
        window.openTab = function (id) {
            document.querySelectorAll('.tab').forEach(e => e.className = 'tab');
            document.querySelectorAll('.content').forEach(e => e.className = 'content');
            document.querySelector(`[data-tab="${id}"]`).className = 'tab active';
            document.getElementById(id).className = 'content active';
        };
        
        // Setup tab listeners (CSP-safe, no inline onclick)
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.tab[data-tab]').forEach(btn => {
                btn.addEventListener('click', () => {
                    window.openTab(btn.getAttribute('data-tab'));
                });
            });
        });

        function resumeGame() {
            if (!controls) {
                alert("Hata: Oyun kontrolleri yüklenemedi. Lütfen internet bağlantınızı kontrol edip sayfayı yenileyiniz.\n\nEğer sorun devam ederse Three.js CDN servisinde sorun olabilir.");
                return;
            }
            const overlay = document.getElementById('menu-overlay');
            if (overlay) overlay.style.display = 'none';
            
            // Canvas'a tıklanınca lock yap (SecurityError yok çünkü gerçek click event içinde)
            const canvas = renderer ? renderer.domElement : null;
            if (canvas && !controls.isLocked) {
                const lockOnClick = () => {
                    canvas.removeEventListener('click', lockOnClick);
                    if (!controls.isLocked) {
                        controls.lock();
                    }
                };
                canvas.addEventListener('click', lockOnClick);
            }
        }

        // --- SEED & NOISE ---
        let currentSeed = Math.floor(Math.random() * 100000);
        initSeed(currentSeed);
        console.log("Map Seed:", currentSeed);

        // --- CONFIG ---
        const GRAVITY = 25.0;
        const SPEED_WALK = 6.0;
        const SPEED_SPRINT = 10.0;
        const JUMP = 9.0;
        const P_HEIGHT = 1.6;
        const P_WIDTH = 0.6;
        const MAX_INSTANCES = 300000; 
        const MAX_PARTICLES = 2000; // Moved here for initialization order
        const MAP_SIZE = 128; // Increased map size (approx 256x256)

        // BLOCKS artık js/blocks.js'den yükleniyor (65+ blok tipi)

        // --- GLOBALS ---
        let camera, scene, renderer, controls;
        let imeshes = [], instanceCounts = [];
        let dummy = new THREE.Object3D();
        let voxelData = new Map();
        let instanceKeys = [];

        let raycaster, selectedSlot = 1;
        let moveState = { f: 0, b: 0, l: 0, r: 0, s: 0, space: 0 };
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let onGround = false;

        let peer, myId, conns = [], remotePlayers = {};
        let myNick = "Oyuncu", myCol = "#00a8ff";
        
        // Graphics settings
        let graphicsQuality = 'medium'; // Default to medium
        let renderDistance = { high: 160, medium: 90, low: 40 };
        let pixelRatio = { high: 1.5, medium: 1.0, low: 0.7 };
        
        // Shader & Optimization Globals
        let animatedMaterials = [];
        
        // Particle System Globals
        let particleMesh;
        let particleData = [];

        // Audio System Globals
        let audioCtx;
        let lastStepTime = 0;

        // Vehicle system
        let vehicles = [];
        let currentVehicle = null;
        let currentVehicleSeat = -1;
        let vehicleControls = { w: 0, s: 0, a: 0, d: 0, space: 0, isDriver: false };
        let hoveredSeat = null; // { vehicle, index }

        // Timing variables (must be declared before animate)
        let last = performance.now();
        let fpsCounter = 0;
        let fpsTime = 0;
        let currentFps = 60;

        // --- SHADER & OPTIMIZATION ---
        
        const SHADER_CHUNKS = {
            pars: `
                uniform float time;
                uniform float windStrength;
            `,
            vertex: `
                // Simple wind effect
                if (windStrength > 0.0) {
                    // Calculate world position approximation for noise consistency
                    // instanceMatrix handles the transform of the instance
                    vec4 worldPos = instanceMatrix * vec4(position, 1.0);
                    
                    // Wind calculation
                    float wind = sin(time * 1.5 + worldPos.x * 0.5 + worldPos.z * 0.5) * windStrength;
                    
                    // Apply to top vertices (BoxGeometry is centered at 0,0,0, so top is y > 0)
                    if (position.y > 0.0) {
                        transformed.x += wind * 0.15;
                        transformed.z += wind * 0.15;
                        // Slight height bob for water/leaves
                        transformed.y += sin(time * 2.0 + worldPos.x) * wind * 0.05;
                    }
                }
            `
        };

        function setupMaterialOptimization(material, blockName) {
            // Only animate Leaves and Water (Grass removed per user request)
            const isAnimatable = ['Leaf', 'Water'].includes(blockName);
            
            if (isAnimatable) {
                material.onBeforeCompile = (shader) => {
                    shader.uniforms.time = { value: 0 };
                    // Set initial value based on current settings
                    const initialWind = graphicsQuality === 'low' ? 0.0 : (graphicsQuality === 'medium' ? 0.2 : 0.5);
                    shader.uniforms.windStrength = { value: initialWind };
                    
                    material.userData.shader = shader;
                    
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <common>',
                        '#include <common>\n' + SHADER_CHUNKS.pars
                    );
                    
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        '#include <begin_vertex>\n' + SHADER_CHUNKS.vertex
                    );
                };
                
                // Add to list for updates
                animatedMaterials.push(material);
            }
        }

        // START
        init();

        function initAudio() {
            if (typeof window.AudioContext === 'undefined' && typeof window.webkitAudioContext === 'undefined') {
                console.warn("Web Audio API not supported");
                return;
            }
            
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
            } catch(e) {
                console.warn("Audio init failed:", e);
            }
        }
        
        function playSound(type) {
            if (!audioCtx) return;
            // Resume context if suspended (browser policy)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(() => {});
            }
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            
            if (type === 'step') {
                // Short noise burst for step
                // Since creating noise buffer is expensive every time, we use a simple low tone
                // or we can create a noise buffer once. Let's use a simple filtered pulse.
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'place') {
                // High pitched click
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'break') {
                // Crunchier sound
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                
                osc.start(now);
                osc.stop(now + 0.15);
            }
        }

        function init() {
            initInventoryData();
            initThree();
            initInstancing();
            initPlantMeshes(); // Bitki sistemi
            initParticles(); // Init particles
            initAudio(); // Init audio
            initWorld();
            initUI();
            initInventoryUI();
            initPeer();
            animate();
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Light sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 50, 120); // Extended fog range to prevent pop-in

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 300); // Extended far plane
            
            // Optimized renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                stencil: false,
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio for performance
            renderer.shadowMap.enabled = false;
            document.body.appendChild(renderer.domElement);

            // Better lighting setup
            const amb = new THREE.AmbientLight(0xffffff, 0.6); // Soft ambient
            scene.add(amb);
            
            const sun = new THREE.DirectionalLight(0xfff5e6, 0.8); // Warm sunlight
            sun.position.set(50, 100, 50);
            scene.add(sun);
            
            // Hemisphere light for sky/ground color blending
            const hemi = new THREE.HemisphereLight(0x87CEEB, 0x3d5c3d, 0.4);
            scene.add(hemi);

            if (typeof THREE.PointerLockControls === 'undefined') throw new Error("PointerLockControls yüklenemedi.");
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
            controls.getObject().position.set(0, 15, 0); // Start at reasonable height
            camera.lookAt(0, 0, 0); // Look toward center

            document.addEventListener('keydown', onKey);
            document.addEventListener('keyup', onKey);
            document.addEventListener('mousedown', onMouse);
            window.addEventListener('resize', onResize);

            raycaster = new THREE.Raycaster();
            
            // Apply initial graphics settings
            applyGraphicsSettings();
        }
        
        function applyGraphicsSettings() {
            const dist = renderDistance[graphicsQuality];
            const ratio = pixelRatio[graphicsQuality];
            
            // Update fog
            scene.fog.near = dist * 0.4;
            scene.fog.far = dist;
            
            // Update camera far plane
            camera.far = dist * 2;
            camera.updateProjectionMatrix();
            
            // Update pixel ratio
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, ratio));
            
            // Update shader uniforms
            const windVal = graphicsQuality === 'low' ? 0.0 : (graphicsQuality === 'medium' ? 0.2 : 0.5);
            animatedMaterials.forEach(mat => {
                if (mat.userData.shader) {
                    mat.userData.shader.uniforms.windStrength.value = windVal;
                }
            });
            
            console.log(`Graphics: ${graphicsQuality.toUpperCase()}, Fog: ${dist}, Ratio: ${ratio}`);
        }

        // Generate procedural texture for a block
        function createBlockTexture(block, faceType = 'side') {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            // Base color (placeholder while loading)
            ctx.fillStyle = '#' + (block.col ? block.col.toString(16).padStart(6, '0') : 'FFFFFF');
            ctx.fillRect(0, 0, size, size);

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.colorSpace = THREE.SRGBColorSpace;

            // Texture Mapping from GitHub Repo
            const BASE_URL = "https://raw.githubusercontent.com/nebulimity/MoreLikeMinecraft/master/default/";
            
            const TEXTURE_MAP = {
                'Grass': { top: 'default_grass.png', side: 'default_grass_side.png', bottom: 'default_dirt.png' },
                'Dirt': 'default_dirt.png',
                'Stone': 'default_stone.png',
                'Cobble': 'default_cobble.png',
                'Brick': 'default_brick.png',
                'Sand': 'default_sand.png',
                'Snow': 'default_snow.png',
                'Water': 'default_water.png',
                'OakLog': { top: 'default_tree_top.png', side: 'default_tree.png', bottom: 'default_tree_top.png' },
                'BirchLog': { top: 'default_aspen_tree_top.png', side: 'default_aspen_tree.png', bottom: 'default_aspen_tree_top.png' },
                'SpruceLog': { top: 'default_pine_tree_top.png', side: 'default_pine_tree.png', bottom: 'default_pine_tree_top.png' },
                'Leaf': 'default_leaves.png'
            };

            let filename = null;
            const map = TEXTURE_MAP[block.name];

            if (map) {
                if (typeof map === 'string') {
                    filename = map;
                } else if (typeof map === 'object') {
                    // Handle top/bottom/side logic
                    if (faceType === 'top') filename = map.top || map.side;
                    else if (faceType === 'bottom') filename = map.bottom || map.side;
                    else filename = map.side;
                }
            }

            if (filename) {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = BASE_URL + filename;
                img.onload = function() {
                    ctx.clearRect(0, 0, size, size);
                    
                    // Special handling for leaves (transparency background)
                    if (block.name === 'Leaf') {
                        ctx.fillStyle = '#2E7D32'; // Dark green background for leaves
                        ctx.fillRect(0, 0, size, size);
                    }
                    
                    ctx.drawImage(img, 0, 0, size, size);
                    
                    // Optional: Overlay color for tinted blocks (like grass top biome tint)
                    // But for now, raw texture is best for "Exact Replica"
                    
                    texture.needsUpdate = true;
                };
            } else {
                // Fallback to procedural if no texture found (e.g. for new blocks)
                // ... (Existing procedural code could go here if needed, but we cover most)
            }

            return texture;
        }

        // Global helper for inventory
        window.getBlockTextureUrl = function(block) {
            const BASE_URL = "https://raw.githubusercontent.com/nebulimity/MoreLikeMinecraft/master/default/";
            const TEXTURE_MAP = {
                'Grass': 'default_grass_side.png', // Use side for icon usually, or top? Let's use side for grass block look
                'Dirt': 'default_dirt.png',
                'Stone': 'default_stone.png',
                'Cobble': 'default_cobble.png',
                'Brick': 'default_brick.png',
                'Sand': 'default_sand.png',
                'Snow': 'default_snow.png',
                'Water': 'default_water.png',
                'OakLog': 'default_tree.png',
                'BirchLog': 'default_aspen_tree.png',
                'SpruceLog': 'default_pine_tree.png',
                'Leaf': 'default_leaves.png'
            };
            
            const map = TEXTURE_MAP[block.name];
            if (map) {
                return BASE_URL + map;
            }
            return null;
        };

        function initInstancing() {
            const geo = new THREE.BoxGeometry(1, 1, 1);
            for (let i = 1; i < BLOCKS.length; i++) {
                const block = BLOCKS[i];
                if (!block) continue;
                
                // Bitki blokları ayrı sistem ile yönetiliyor (plants.js)
                if (block.type === BLOCK_TYPE.PLANT) {
                    imeshes[i] = null;
                    instanceCounts[i] = 0;
                    instanceKeys[i] = [];
                    continue;
                }
                
                let mat;
                
                // Çok yüzlü bloklar (farklı üst/yan texture)
                const multiTexBlocks = ['Grass', 'OakLog', 'BirchLog', 'SpruceLog', 'JungleLog', 'Cactus'];
                if (multiTexBlocks.some(n => block.name.includes(n))) {
                    const mats = [];
                    // Order: Right, Left, Top, Bottom, Front, Back
                    const sides = ['side', 'side', 'top', 'bottom', 'side', 'side'];
                    for(let j=0; j<6; j++) {
                        const tex = createBlockTexture(block, sides[j]);
                        const m = new THREE.MeshLambertMaterial({ map: tex });
                        // Transparan bloklar için
                        if (block.type === BLOCK_TYPE.TRANSPARENT) {
                            m.transparent = true;
                            m.opacity = block.opacity || 0.9;
                        }
                        // Apply shader optimization (wind effects)
                        setupMaterialOptimization(m, block.name);
                        mats.push(m);
                    }
                    mat = mats;
                } else {
                    const texture = createBlockTexture(block, 'all');
                    mat = new THREE.MeshLambertMaterial({ map: texture });
                    // Transparan bloklar için
                    if (block.type === BLOCK_TYPE.TRANSPARENT) {
                        mat.transparent = true;
                        mat.opacity = block.opacity || 0.9;
                    }
                    // Sıvı bloklar
                    if (block.type === BLOCK_TYPE.LIQUID) {
                        mat.transparent = true;
                        mat.opacity = 0.7;
                    }
                    // Apply shader optimization (wind effects)
                    setupMaterialOptimization(mat, block.name);
                }

                const mesh = new THREE.InstancedMesh(geo, mat, MAX_INSTANCES);
                mesh.castShadow = false; // Disable for performance
                mesh.receiveShadow = false;
                mesh.count = 0;
                // IMPORTANT: Disable frustum culling for InstancedMesh
                // Three.js can't properly cull individual instances, causing entire mesh to disappear
                mesh.frustumCulled = false;
                scene.add(mesh);
                imeshes[i] = mesh;
                instanceCounts[i] = 0;
                instanceKeys[i] = [];
            }
        }

        function setBlock(x, y, z, type, broadcast = true) {
            const key = `${x},${y},${z}`;
            const wasRemoved = voxelData.has(key) && type === 0;
            
            if (voxelData.has(key)) {
                const old = voxelData.get(key);
                if (old.type === type) return;
                
                // Spawn particles on removal
                if (type === 0) {
                    const blockInfo = BLOCKS[old.type];
                    // Use side color as approximation, or default to gray
                    const col = blockInfo ? (blockInfo.side || blockInfo.col) : 0x888888;
                    spawnParticles(x, y, z, col);
                }

                // Bitki mi normal blok mu?
                const oldBlock = BLOCKS[old.type];
                if (oldBlock && oldBlock.type === BLOCK_TYPE.PLANT) {
                    removePlantInstance(x, y, z);
                } else {
                    removeInstance(old.type, old.index);
                }
                voxelData.delete(key);
                if (broadcast) Broadcast({ t: 'blk', a: 'rm', x, y, z });
            }

            if (type > 0) {
                const block = BLOCKS[type];
                if (block && block.type === BLOCK_TYPE.PLANT) {
                    // Bitki olarak ekle
                    if (addPlantInstance(x, y, z, type)) {
                        voxelData.set(key, { type, index: -1 }); // index -1 for plants
                        if (broadcast) Broadcast({ t: 'blk', a: 'add', x, y, z, v: type });
                    }
                } else {
                    // Normal blok
                    const idx = addInstance(type, x, y, z);
                    if (idx !== -1) {
                        voxelData.set(key, { type, index: idx });
                        instanceKeys[type][idx] = key;
                        if (broadcast) Broadcast({ t: 'blk', a: 'add', x, y, z, v: type });
                    }
                }
            }
            
            // When a block is removed, check if player was standing on it and allow falling
            if (wasRemoved && controls) {
                const p = controls.getObject().position;
                // Check if player was on or near this block
                const playerFootY = p.y - P_HEIGHT;
                if (Math.abs(p.x - x) < 1.5 && Math.abs(p.z - z) < 1.5 && 
                    playerFootY >= y - 0.5 && playerFootY <= y + 1.5) {
                    // Reset onGround to allow gravity to take effect
                    onGround = false;
                }
            }
            
            document.getElementById('blk').innerText = voxelData.size;
        }

        function addInstance(type, x, y, z) {
            const mesh = imeshes[type];
            if (!mesh) return -1; // Bitki blokları için mesh yok
            const cnt = instanceCounts[type];
            if (cnt >= MAX_INSTANCES) return -1;
            dummy.position.set(x, y, z);
            dummy.updateMatrix();
            mesh.setMatrixAt(cnt, dummy.matrix);
            mesh.instanceMatrix.needsUpdate = true;
            instanceCounts[type]++;
            mesh.count = instanceCounts[type];
            return cnt;
        }

        function removeInstance(type, idx) {
            const mesh = imeshes[type];
            if (!mesh) return; // Bitki blokları için mesh yok
            const cnt = instanceCounts[type];
            const last = cnt - 1;

            if (idx !== last) {
                const mat = new THREE.Matrix4();
                mesh.getMatrixAt(last, mat);
                mesh.setMatrixAt(idx, mat);
                const lastKey = instanceKeys[type][last];
                instanceKeys[type][idx] = lastKey;
                const d = voxelData.get(lastKey);
                if (d) d.index = idx;
            }

            instanceCounts[type]--;
            mesh.count = instanceCounts[type];
            mesh.instanceMatrix.needsUpdate = true;
        }

        // Chunk sistemi kullanılacak mı?
        const USE_CHUNK_SYSTEM = true;
        
        function initWorld() {
            // Ground plane (water level) - covers entire map
            const waterSize = USE_CHUNK_SYSTEM ? 2000 : MAP_SIZE * 2.5;
            const waterGeo = new THREE.PlaneGeometry(waterSize, waterSize);
            const waterMat = new THREE.MeshLambertMaterial({ 
                color: 0x1E88E5, 
                transparent: true, 
                opacity: 0.6 
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0.5;
            scene.add(water);

            if (USE_CHUNK_SYSTEM) {
                // Chunk tabanlı dünya - lazy loading
                initChunkSystem();
                console.log("[World] Chunk-based world system active");
                // İlk chunk'ları yükle (spawn etrafında)
                const startTime = performance.now();
                for (let dx = -3; dx <= 3; dx++) {
                    for (let dz = -3; dz <= 3; dz++) {
                        const chunk = getOrCreateChunk(dx, dz);
                        generateChunk(chunk);
                        buildChunkMesh(chunk);
                    }
                }
                console.log(`[World] Initial chunks loaded in ${(performance.now() - startTime).toFixed(0)}ms`);
            } else {
                // Eski sistem - tüm haritayı bir seferde oluştur
                const startTime = performance.now();
                let blockCount = 0;
                let plantCount = 0;
                
                const enableCaves = graphicsQuality !== 'low';
                
                for (let x = -MAP_SIZE; x <= MAP_SIZE; x++) {
                    for (let z = -MAP_SIZE; z <= MAP_SIZE; z++) {
                        let n1 = noise2D(x / 60, z / 60); 
                        let n2 = noise2D(x / 20, z / 20) * 0.2;
                        let n = (n1 + n2);
                        let biome = noise2D(x / 150, z / 150);
                        let h = Math.floor((n + 1) * 4) + 4; 
                        
                        setBlock(x, 0, z, 63, false);
                        blockCount++;

                        for (let y = 1; y < h; y++) {
                            let type = 3;
                            
                            if (enableCaves && y > 1 && y < h - 2) {
                                const caveNoise = noise3D(x / 20, y / 20, z / 20);
                                if (caveNoise > 0.4) continue;
                            }
                            
                            if (y < h - 3) {
                                const oreRoll = Math.abs((x * 7919 + y * 6997 + z * 5653) % 10000) / 10000;
                                if (y <= 16 && oreRoll < 0.002) type = 24;
                                else if (y <= 16 && oreRoll < 0.010) type = 26;
                                else if (y <= 32 && oreRoll < 0.006) type = 23;
                                else if (y <= 64 && oreRoll < 0.015) type = 22;
                                else if (oreRoll < 0.020) type = 21;
                            }
                            
                            if (y === h - 1) {
                                if (h <= 5) type = 7;
                                else if (h > 10) type = 8;
                                else type = 1;
                            } else if (y >= h - 4) {
                                type = 2;
                            }
                            
                            setBlock(x, y, z, type, false);
                            blockCount++;
                        }
                        
                        if (h > 5 && h <= 10) {
                            const decorRoll = Math.abs((x * 3571 + z * 2953) % 1000) / 1000;
                            if (decorRoll < 0.12) {
                                setBlock(x, h, z, 44, false);
                                plantCount++;
                            } else if (decorRoll < 0.16) {
                                let flowerId = 36 + Math.floor(Math.abs((x * 123 + z * 456) % 6));
                                setBlock(x, h, z, flowerId, false);
                                plantCount++;
                            }
                        }
                        
                        if (Math.abs(x * z * 123) % 100 < 2 && h > 5 && h <= 10) {
                            let treeType = biome > 0.2 ? 'spruce' : (biome < -0.2 ? 'birch' : 'oak');
                            tree(x, h, z, treeType);
                        }
                    }
                }
                console.log(`World generated: ${blockCount} blocks, ${plantCount} plants in ${(performance.now() - startTime).toFixed(0)}ms`);
            }
            
            // Spawn a car near spawn point
            spawnVehicle(5, 10, 5);
        }

        function tree(x, y, z, type = 'oak') {
            let logId = 4; // Oak
            if (type === 'birch') logId = 11;
            if (type === 'spruce') logId = 12;

            if (type === 'spruce') {
                // Tall pine style
                const height = 6 + Math.floor(Math.random() * 3);
                for (let i = 0; i < height; i++) setBlock(x, y + i, z, logId, false);
                
                // Cone leaves
                for (let i = 2; i < height; i++) {
                    const radius = Math.floor((height - i) / 3) + 1;
                    for (let lx = x - radius; lx <= x + radius; lx++) {
                        for (let lz = z - radius; lz <= z + radius; lz++) {
                            if (Math.abs(lx - x) + Math.abs(lz - z) <= radius + 0.5) {
                                if (lx !== x || lz !== z || i === height-1) 
                                    setBlock(lx, y + i, lz, 5, false);
                            }
                        }
                    }
                }
                setBlock(x, y + height, z, 5, false);
            } else if (type === 'birch') {
                // Tall straight
                const height = 5 + Math.floor(Math.random() * 2);
                for (let i = 0; i < height; i++) setBlock(x, y + i, z, logId, false);
                
                // Leaves at top
                for (let lx = x - 2; lx <= x + 2; lx++)
                    for (let lz = z - 2; lz <= z + 2; lz++)
                        if (lx !== x || lz !== z) setBlock(lx, y + height - 1, lz, 5, false);
                setBlock(x, y + height, z, 5, false);
            } else {
                // Oak (Standard)
                const height = 4 + Math.floor(Math.random() * 2);
                for (let i = 0; i < height; i++) setBlock(x, y + i, z, logId, false);
                
                for (let lx = x - 2; lx <= x + 2; lx++)
                    for (let lz = z - 2; lz <= z + 2; lz++)
                        if (lx !== x || lz !== z) setBlock(lx, y + height - 1, lz, 5, false);
                setBlock(x, y + height, z, 5, false);
            }
        }

        // --- PARTICLE SYSTEM ---
        // particleMesh and particleData moved to globals
        // MAX_PARTICLES moved to top
        
        function initParticles() {
            const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            particleMesh = new THREE.InstancedMesh(geo, mat, MAX_PARTICLES);
            particleMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            particleMesh.count = 0;
            scene.add(particleMesh);
            
            // Initialize data pool
            for(let i=0; i<MAX_PARTICLES; i++) {
                particleData.push({
                    active: false,
                    life: 0,
                    velocity: new THREE.Vector3(),
                    position: new THREE.Vector3()
                });
            }
        }
        
        function spawnParticles(x, y, z, colorHex) {
            // Determine count based on graphics quality
            let count = graphicsQuality === 'high' ? 12 : (graphicsQuality === 'medium' ? 6 : 2);
            
            const color = new THREE.Color(colorHex || 0xffffff);
            
            for(let i=0; i<count; i++) {
                // Find free slot
                const p = particleData.find(d => !d.active);
                if(!p) break; // Pool full
                
                p.active = true;
                p.life = 1.0 + Math.random() * 0.5; // 1-1.5 seconds life
                
                // Random position within block
                p.position.set(
                    x + (Math.random() - 0.5) * 0.8,
                    y + (Math.random() - 0.5) * 0.8,
                    z + (Math.random() - 0.5) * 0.8
                );
                
                // Explosion velocity
                p.velocity.set(
                    (Math.random() - 0.5) * 4,
                    (Math.random() * 3) + 1, // Upward bias
                    (Math.random() - 0.5) * 4
                );
                
                // Set color for this instance
                particleMesh.setColorAt(particleData.indexOf(p), color);
            }
            
            particleMesh.instanceColor.needsUpdate = true;
        }
        
        function updateParticles(dt) {
            if(!particleMesh) return;
            
            let activeCount = 0;
            const dummy = new THREE.Object3D();
            
            particleData.forEach((p, i) => {
                if(!p.active) return;
                
                // Physics
                p.velocity.y -= 9.8 * dt; // Gravity
                p.position.addScaledVector(p.velocity, dt);
                
                // Floor collision (simple)
                if(p.position.y < 0) {
                    p.position.y = 0;
                    p.velocity.y *= -0.5; // Bounce
                    p.velocity.x *= 0.8; // Friction
                    p.velocity.z *= 0.8;
                }
                
                // Life
                p.life -= dt;
                if(p.life <= 0) {
                    p.active = false;
                    // Move offscreen
                    dummy.position.set(0, -1000, 0);
                    dummy.updateMatrix();
                    particleMesh.setMatrixAt(i, dummy.matrix);
                } else {
                    // Update visual
                    dummy.position.copy(p.position);
                    // Scale down as it dies
                    const scale = p.life; 
                    dummy.scale.set(scale, scale, scale);
                    dummy.updateMatrix();
                    particleMesh.setMatrixAt(i, dummy.matrix);
                    activeCount++;
                }
            });
            
            particleMesh.count = MAX_PARTICLES; // Always draw full buffer, but inactive ones are hidden
            particleMesh.instanceMatrix.needsUpdate = true;
        }

        function initUI() {
            // Hotbar is initialized by inventory.js

            document.getElementById('btn-close-menu').onclick = resumeGame;
            const singleBtn = document.getElementById('btn-single');
            if (singleBtn) singleBtn.onclick = resumeGame;
            
            // ESC key handler (WebView2/Tauri-safe)
            // Important: if pointer lock stays active, clicks target the lock element (not the menu),
            // so tabs/color picker appear "unclickable". We must unlock when showing the menu.
            const onEscape = (e) => {
                if (e.code !== 'Escape' || e.repeat) return;
                
                // If inventory is open, close it first
                if (typeof isInventoryOpen !== 'undefined' && isInventoryOpen) {
                    toggleInventory();
                    return;
                }

                const overlay = document.getElementById('menu-overlay');
                if (!overlay) return;

                const menuOpen = overlay.style.display === 'flex';
                if (menuOpen) {
                    // Menu open -> close (lock on next input)
                    resumeGame();
                    return;
                }

                // Menu closed -> show immediately and force unlock so UI can receive clicks
                overlay.style.display = 'flex';
                try {
                    if (controls && controls.isLocked && typeof controls.unlock === 'function') {
                        controls.unlock();
                    } else {
                        document.exitPointerLock();
                    }
                } catch (_) { }
            };
            window.addEventListener('keydown', onEscape, { capture: true });
            
            // Simple ESC menu handler using unlock event
            controls.addEventListener('unlock', () => {
                // Don't show menu if inventory is open
                if (typeof isInventoryOpen !== 'undefined' && isInventoryOpen) return;

                // When pointer unlocks, show menu
                const overlay = document.getElementById('menu-overlay');
                if (overlay) overlay.style.display = 'flex';
            });
            
            controls.addEventListener('lock', () => {
                // When pointer locks, hide menu
                document.getElementById('menu-overlay').style.display = 'none';
            });

            const nI = document.getElementById('inp-nick');
            const cI = document.getElementById('inp-color');
            const sync = () => { 
                myNick = nI.value; 
                myCol = cI.value; 
                // Include ID in profile broadcast
                Broadcast({ t: 'p', i: myId, n: myNick, c: myCol }); 
            };
            nI.addEventListener('input', sync); 
            cI.addEventListener('input', sync);
            cI.addEventListener('change', sync);

            document.getElementById('btn-single').onclick = resumeGame;

            document.getElementById('btn-host').onclick = () => {
                resumeGame(); document.getElementById('status').innerText = "Host Aktif.";
            };
            document.getElementById('btn-join').onclick = () => {
                const id = document.getElementById('host-id').value.trim();
                if (id && peer) {
                    document.getElementById('status').innerText = "Bağlanıyor...";
                    const conn = peer.connect(id);
                    conn.on('open', () => {
                        SetupConn(conn);
                        resumeGame();
                        document.getElementById('status').innerText = "Bağlandı!";
                    });
                    conn.on('error', (err) => {
                        document.getElementById('status').innerText = "Hata: " + err;
                    });
                } else {
                    document.getElementById('status').innerText = "ID giriniz!";
                }
            };
            
            // Graphics quality selector
            document.getElementById('quality-select').value = graphicsQuality;
            document.getElementById('quality-select').onchange = (e) => {
                graphicsQuality = e.target.value;
                applyGraphicsSettings();
                console.log('Graphics changed to:', graphicsQuality);
            };
        }

        function selectSlot(i) {
            if (i < 1 || i > 9) return;
            selectedSlot = i;
            document.querySelectorAll('.slot').forEach(el => el.className = 'slot');
            const el = document.getElementById(`slot-${i}`);
            if(el) el.className = 'slot active';
        }



        function onKey(e) {
            const d = e.type === 'keydown';
            
            // Vehicle controls (only if in vehicle)
            if (currentVehicle) {
                switch (e.code) {
                    case 'KeyW': vehicleControls.w = d; break;
                    case 'KeyS': vehicleControls.s = d; break;
                    case 'KeyA': vehicleControls.a = d; break;
                    case 'KeyD': vehicleControls.d = d; break;
                    case 'Space': vehicleControls.space = d; break;
                    case 'KeyF': 
                        if (d) {
                            // If looking at another seat inside the same vehicle, switch to it
                            if (hoveredSeat && hoveredSeat.vehicle === currentVehicle && hoveredSeat.index !== currentVehicleSeat) {
                                switchSeat(hoveredSeat.index);
                            } else {
                                // Otherwise exit
                                exitVehicle(); 
                            }
                        }
                        break;
                }
                return; // Don't process player movement while in vehicle
            }

            // Player controls
            switch (e.code) {
                case 'KeyE': if(d) toggleInventory(); break;
                case 'KeyW': moveState.f = d; break;
                case 'KeyS': moveState.b = d; break;
                case 'KeyA': moveState.l = d; break;
                case 'KeyD': moveState.r = d; break;
                case 'Space': moveState.space = d; break;
                case 'ShiftLeft': moveState.s = d; break;
                case 'KeyF':
                    if (d) {
                        if (hoveredSeat) {
                            // Enter specific seat if looking at one
                            if (hoveredSeat.vehicle.seats[hoveredSeat.index].occupied === null) {
                                enterVehicle(hoveredSeat.vehicle, hoveredSeat.index);
                            } else {
                                // Optional: Feedback that seat is taken
                                console.log("Seat occupied");
                            }
                        } else {
                            // Fallback to nearest vehicle (auto-seat)
                            tryEnterNearbyVehicle();
                        }
                    }
                    break;
            }
            if (d && e.key >= '1' && e.key <= '9') selectSlot(parseInt(e.key));
        }



        function onMouse(e) {
            if (!controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const hits = raycaster.intersectObjects(imeshes.filter(m => m));

            if (hits.length > 0) {
                const h = hits[0];
                const p = h.point.clone().add(h.face.normal.clone().multiplyScalar(0.5));
                const rmP = h.point.clone().add(h.face.normal.clone().multiplyScalar(-0.5));
                const bx = Math.round(p.x); const by = Math.round(p.y); const bz = Math.round(p.z);
                const rx = Math.round(rmP.x); const ry = Math.round(rmP.y); const rz = Math.round(rmP.z);

                if (e.button === 0) { // Left: Break
                    setBlock(rx, ry, rz, 0);
                    playSound('break');
                }
                else if (e.button === 1) { // Middle: Pick
                    const k = `${rx},${ry},${rz}`;
                    const d = voxelData.get(k);
                    if (d) {
                        const idx = hotbar.indexOf(d.type);
                        if (idx !== -1) {
                            selectSlot(idx + 1);
                        } else {
                            hotbar[selectedSlot - 1] = d.type;
                            updateHudHotbar();
                        }
                    }
                }
                else if (e.button === 2) { // Right: Place
                    const type = hotbar[selectedSlot - 1];
                    if (type > 0 && !aabbTest(controls.getObject().position, bx, by, bz)) {
                        setBlock(bx, by, bz, type);
                        playSound('place');
                    }
                }
            }
        }

        function updatePhys(dt) {
            if (currentVehicle) {
                updateVehiclePhysics(dt);
                return; // Don't update player physics when in vehicle
            }

            // Y Physics (Gravity)
            velocity.y -= GRAVITY * dt;

            // Input Movement (World Axis)
            const moveSpeed = (moveState.s ? SPEED_SPRINT : SPEED_WALK) * dt;
            const camDir = new THREE.Vector3(); controls.getDirection(camDir); camDir.y = 0; camDir.normalize();
            const sideDir = new THREE.Vector3(); sideDir.crossVectors(controls.getObject().up, camDir).normalize();

            const dx = new THREE.Vector3();
            if (moveState.f) dx.add(camDir);
            if (moveState.b) dx.sub(camDir);
            if (moveState.l) dx.add(sideDir);
            if (moveState.r) dx.sub(sideDir);
            dx.normalize().multiplyScalar(moveSpeed);

            const p = controls.getObject().position;

            // Apply X/Z Move
            p.x += dx.x; p.z += dx.z;
            
            // Footstep sounds
            if (onGround && (moveState.f || moveState.b || moveState.l || moveState.r)) {
                const now = performance.now();
                const stepInterval = moveState.s ? 300 : 500; // Faster steps when sprinting
                if (now - lastStepTime > stepInterval) {
                    playSound('step');
                    lastStepTime = now;
                }
            }
            
            if (checkCol(p)) {
                // Simple separate axis resolution basic
                p.x -= dx.x;
                if (checkCol(p)) { p.x += dx.x; p.z -= dx.z; } // Try X only
                if (checkCol(p)) { p.x -= dx.x; } // Neither worked, stay put
            }

            // Y Physics
            p.y += velocity.y * dt;
            onGround = false;
            // Check Head Collision first (Upward movement or jump)
            if (velocity.y > 0 && checkCol(p)) {
                p.y -= velocity.y * dt;
                velocity.y = 0;
            }
            // Check Foot Collision (Gravity)
            else if (checkCol(p)) {
                p.y -= velocity.y * dt;
                if (velocity.y < 0) {
                    onGround = true;
                    // Auto-jump (Bunny hopping)
                    if (moveState.space) {
                        velocity.y = JUMP;
                        onGround = false;
                    } else {
                        velocity.y = 0;
                    }
                } else {
                    velocity.y = 0;
                }
            }
            if (p.y < -30) { p.set(0, 30, 0); velocity.set(0, 0, 0); }
        }

        function checkCol(p) {
            // Precise AABB vs Block Voxel
            // Player AABB - slightly smaller to allow standing on edges better
            const edgeMargin = 0.05; // Small margin to help with edge standing
            const minX = p.x - P_WIDTH / 2 + edgeMargin; 
            const maxX = p.x + P_WIDTH / 2 - edgeMargin;
            const minY = p.y - P_HEIGHT; 
            const maxY = p.y;
            const minZ = p.z - P_WIDTH / 2 + edgeMargin; 
            const maxZ = p.z + P_WIDTH / 2 - edgeMargin;

            // Broadphase range (Increase range to catch leaves above head)
            const iMinX = Math.floor(p.x - P_WIDTH / 2 - 0.5); 
            const iMaxX = Math.floor(p.x + P_WIDTH / 2 + 0.5);
            const iMinY = Math.floor(minY - 0.5); 
            const iMaxY = Math.floor(maxY + 1.5);
            const iMinZ = Math.floor(p.z - P_WIDTH / 2 - 0.5); 
            const iMaxZ = Math.floor(p.z + P_WIDTH / 2 + 0.5);

            for (let x = iMinX; x <= iMaxX; x++) {
                for (let y = iMinY; y <= iMaxY; y++) {
                    for (let z = iMinZ; z <= iMaxZ; z++) {
                        if (voxelData.has(`${x},${y},${z}`)) {
                            // Block AABB (Centered at x,y,z with size 1)
                            const bMinX = x - 0.5; const bMaxX = x + 0.5;
                            const bMinY = y - 0.5; const bMaxY = y + 0.5;
                            const bMinZ = z - 0.5; const bMaxZ = z + 0.5;

                            if (minX < bMaxX && maxX > bMinX &&
                                minY < bMaxY && maxY > bMinY &&
                                minZ < bMaxZ && maxZ > bMinZ) return true;
                        }
                    }
                }
            }
            return false;
        }

        // Remove old 'check'
        function check(p) { return checkCol(p); }
        function aabbTest(p, x, y, z) {
            const r = P_WIDTH / 2;
            return (p.x + r > x - 0.5 && p.x - r < x + 0.5 && p.z + r > z - 0.5 && p.z - r < z + 0.5 && p.y > y - 0.5 && p.y - P_HEIGHT < y + 0.5);
        }



        function initPeer() {
            if (typeof Peer === 'undefined') return;
            peer = new Peer();
            peer.on('open', id => { myId = id; document.getElementById('my-id').value = id; });
            peer.on('connection', SetupConn);
        }
        function SetupConn(c) {
            conns.push(c);
            c.on('data', d => {
                if (d.t === 'm') {
                    UpdPlayer(d);
                    // Relay movement to other connections (mesh network)
                    relayToOthers(d, c);
                }
                if (d.t === 'blk') {
                    setBlock(d.x, d.y, d.z, d.a === 'add' ? d.v : 0, false);
                    // Relay block changes to others
                    relayToOthers(d, c);
                }
                if (d.t === 'p') {
                    UpdProf(d);
                    // Relay profile to others
                    relayToOthers(d, c);
                }
                if (d.t === 'v') {
                    // Vehicle position update
                    updateRemoteVehicle(d);
                    // Relay to others
                    relayToOthers(d, c);
                }
                if (d.t === 'vehicleEnter') {
                    // Remote player entered vehicle
                    handleRemoteVehicleEnter(d);
                    relayToOthers(d, c);
                }
                if (d.t === 'vehicleExit') {
                    // Remote player exited vehicle
                    handleRemoteVehicleExit(d);
                    relayToOthers(d, c);
                }
                // Handle peer list for mesh network
                if (d.t === 'peers') {
                    d.list.forEach(peerId => {
                        if (peerId !== myId && !conns.find(conn => conn.peer === peerId)) {
                            console.log('Connecting to peer:', peerId);
                            const newConn = peer.connect(peerId);
                            newConn.on('open', () => SetupConn(newConn));
                        }
                    });
                }
            });
            
            // Send current profile with ID
            c.send({ t: 'p', i: myId, n: myNick, c: myCol });
            
            // Send list of known peers for mesh networking
            const peerList = conns.map(conn => conn.peer).filter(p => p && p !== c.peer);
            if (peerList.length > 0) {
                c.send({ t: 'peers', list: peerList });
            }
            
            // Sync world to new player
            console.log('New player connected, syncing world...');
            setTimeout(() => {
                syncWorldToConnection(c);
            }, 500);
            
            console.log('Total connections:', conns.length);
        }
        
        // Relay messages to all connections except the source
        function relayToOthers(msg, sourceConn) {
            conns.forEach(c => {
                if (c !== sourceConn && c.open) {
                    try { c.send(msg); } catch(e) {}
                }
            });
        }
        
        // Send world state to a specific connection
        function syncWorldToConnection(c) {
            if (!c.open) return;
            let sent = 0;
            voxelData.forEach((data, key) => {
                const [x, y, z] = key.split(',').map(Number);
                c.send({ t: 'blk', a: 'add', x, y, z, v: data.type });
                sent++;
            });
            console.log(`Synced ${sent} blocks`);
        }
        
        function Broadcast(m) { 
            conns.forEach(c => {
                if (c.open) {
                    try { c.send(m); } catch(e) { console.warn('Send failed:', e); }
                }
            }); 
        }



        function UpdPlayer(d) {
            if (!d.i || d.i === myId) return; // Don't create player for self
            
            if (!remotePlayers[d.i]) {
                console.log('Creating remote player:', d.i);
                const g = new THREE.Group();
                
                // Body
                const m = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.9, 0.4), 
                    new THREE.MeshLambertMaterial({ color: 0xffffff })
                );
                m.position.y = 0.45; 
                g.add(m);
                
                // Head
                const h = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.4, 0.4), 
                    new THREE.MeshLambertMaterial({ color: 0xffccaa })
                );
                h.position.y = 1.1; 
                g.add(h);
                
                // Nametag sprite - properly configured
                const spriteMat = new THREE.SpriteMaterial({ 
                    transparent: true,
                    depthTest: false,
                    depthWrite: false
                });
                const s = new THREE.Sprite(spriteMat);
                s.position.y = 1.8; 
                s.scale.set(3, 0.75, 1); 
                g.add(s);
                
                scene.add(g);
                remotePlayers[d.i] = { 
                    m: g, 
                    tp: new THREE.Vector3(), 
                    tr: 0, 
                    nick: '', 
                    col: '#ffffff',
                    inVehicle: false,
                    vehicleId: null,
                    seatIndex: -1
                };
            }
            const p = remotePlayers[d.i];
            
            // Only update position if not in vehicle
            if (!p.inVehicle) {
                p.tp.set(d.x, d.y - 1.6, d.z);
            }
        }
        function UpdProf(d) {
            if (!d.i || d.i === myId) return; // Don't update self
            
            // Create player if doesn't exist
            if (!remotePlayers[d.i]) {
                UpdPlayer({ i: d.i, x: 0, y: 10, z: 0 });
            }
            
            const p = remotePlayers[d.i];
            if (!p) return;
            
            // Update body color
            try {
                p.m.children[0].material.color.set(d.c);
            } catch(e) { console.warn('Color set failed:', e); }
            
            // Store profile data
            p.nick = d.n;
            p.col = d.c;
            
            // Minecraft-style nametag
            const C = document.createElement('canvas'); 
            C.width = 512; 
            C.height = 128;
            const X = C.getContext('2d');
            
            // Clear canvas with transparency
            X.clearRect(0, 0, 512, 128);
            
            // Setup font
            X.font = "bold 36px Arial, sans-serif";
            X.textAlign = "center";
            X.textBaseline = "middle";
            const textWidth = X.measureText(d.n).width;
            
            // Draw semi-transparent black background (Minecraft style)
            const padding = 16;
            const bgX = 256 - textWidth / 2 - padding;
            const bgWidth = textWidth + padding * 2;
            const bgHeight = 50;
            const bgY = 39;
            
            // Rounded rect background
            X.fillStyle = "rgba(0, 0, 0, 0.5)";
            X.beginPath();
            X.roundRect(bgX, bgY, bgWidth, bgHeight, 4);
            X.fill();
            
            // Draw text shadow (Minecraft has dark shadow)
            X.fillStyle = "#3F3F3F";
            X.fillText(d.n, 258, 51);
            
            // Draw main text (white)
            X.fillStyle = "#FFFFFF";
            X.fillText(d.n, 256, 48);
            
            const texture = new THREE.CanvasTexture(C);
            texture.minFilter = THREE.LinearFilter;
            p.m.children[2].material.map = texture;
            p.m.children[2].material.needsUpdate = true;
        }

        // window.openTab moved to top
        function onResize() {
            camera.aspect = innerWidth / innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const t = performance.now();
            const dt = Math.min((t - last) / 1000, 0.1); // Cap delta time to prevent huge jumps
            last = t;
            
            // Update shader time
            const timeSec = t / 1000;
            animatedMaterials.forEach(mat => {
                if (mat.userData.shader) {
                    mat.userData.shader.uniforms.time.value = timeSec;
                }
            });
            
            // Update plants (wind animation)
            if (typeof updatePlants === 'function') {
                updatePlants(timeSec);
            }
            
            // Update chunk system (lazy loading)
            if (USE_CHUNK_SYSTEM && controls && controls.isLocked) {
                const p = controls.getObject().position;
                updateChunks(p.x, p.z);
            }
            
            // Update particles
            updateParticles(dt);
            
            // FPS counter (update every 500ms for stability)
            fpsCounter++;
            fpsTime += dt;
            if (fpsTime >= 0.5) {
                currentFps = Math.round(fpsCounter / fpsTime);
                document.getElementById('fps').innerText = currentFps;
                fpsCounter = 0;
                fpsTime = 0;
            }
            
            if (controls.isLocked) {
                updatePhys(dt);
                const p = controls.getObject().position;
                // Throttle network broadcasts (every 50ms instead of every frame)
                if (t % 50 < 20) {
                    Broadcast({ t: 'm', i: myId, x: p.x, y: p.y, z: p.z });
                }

                // Seat selection raycast (works both inside and outside vehicle)
                raycaster.setFromCamera({ x: 0, y: 0 }, camera);
                let hitSeat = null;
                
                // Collect all seat meshes from all vehicles
                const allSeatMeshes = [];
                vehicles.forEach(v => {
                    if (v.seatMeshes) {
                        v.seatMeshes.forEach(mesh => allSeatMeshes.push(mesh));
                    }
                });
                
                // If inside vehicle, ignore current seat mesh to allow looking through it? 
                // Actually we want to see other seats.
                
                const intersects = raycaster.intersectObjects(allSeatMeshes, true);
                if (intersects.length > 0 && intersects[0].distance < 5) {
                    // Find the parent group that represents the seat
                    let obj = intersects[0].object;
                    while (obj && !obj.userData.isSeat && obj.parent) {
                        obj = obj.parent;
                    }
                    
                    if (obj && obj.userData.isSeat) {
                        hitSeat = { 
                            vehicle: obj.userData.vehicle, 
                            index: obj.userData.seatIndex,
                            name: obj.userData.seatName
                        };
                    }
                }
                
                hoveredSeat = hitSeat;
                
                // Update Crosshair
                const ch = document.getElementById('crosshair');
                if (hoveredSeat) {
                    // If in vehicle, only highlight if it's a different seat in same vehicle
                    if (currentVehicle) {
                        if (hoveredSeat.vehicle === currentVehicle && hoveredSeat.index !== currentVehicleSeat) {
                            ch.style.borderColor = '#48dbfb';
                            ch.style.transform = 'translate(-50%, -50%) scale(1.5)';
                            ch.style.backgroundColor = 'rgba(72, 219, 251, 0.2)';
                        } else {
                            // Reset if looking at own seat or outside vehicle seats (though unlikely to reach outside seats)
                            ch.style.borderColor = 'rgba(255, 255, 255, 0.8)';
                            ch.style.transform = 'translate(-50%, -50%) scale(1)';
                            ch.style.backgroundColor = 'transparent';
                        }
                    } else {
                        // Outside vehicle
                        ch.style.borderColor = '#48dbfb';
                        ch.style.transform = 'translate(-50%, -50%) scale(1.5)';
                        ch.style.backgroundColor = 'rgba(72, 219, 251, 0.2)';
                    }
                } else {
                    ch.style.borderColor = 'rgba(255, 255, 255, 0.8)';
                    ch.style.transform = 'translate(-50%, -50%) scale(1)';
                    ch.style.backgroundColor = 'transparent';
                }
            }
            
            // Smooth remote player interpolation
            for (let k in remotePlayers) {
                const rp = remotePlayers[k];
                
                // If player is in vehicle, position them in their seat (sitting pose)
                if (rp.inVehicle && rp.vehicleId) {
                    const vehicle = vehicles.find(v => v.id === rp.vehicleId);
                    if (vehicle && vehicle.seats && rp.seatIndex !== -1) {
                        const seatPos = vehicle.seats[rp.seatIndex].pos.clone();
                        const upVector = new THREE.Vector3(0, 1, 0);
                        seatPos.applyAxisAngle(upVector, vehicle.rotation.y);
                        rp.m.position.copy(vehicle.position).add(seatPos);
                        rp.m.position.y -= 0.9; // Sitting position (lower than standing)
                        rp.m.visible = true; // Show player in vehicle
                        
                        // Rotate player to face forward in vehicle
                        rp.m.rotation.y = vehicle.rotation.y;
                    }
                } else {
                    // Normal movement interpolation
                    rp.m.position.lerp(rp.tp, Math.min(10 * dt, 1));
                    rp.m.visible = true;
                }
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>