<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <title>Voxel Velocity - Final</title>
    <link rel="stylesheet" href="./css/main-menu.css">
    <style>
        :root {
            --ui-font: 'Segoe UI', sans-serif;

            --ui-overlay: rgba(15, 20, 30, 0.78);
            --ui-panel: #222f3e;
            --ui-panel-2: #2f3640;
            --ui-panel-3: #353b48;
            --ui-border: #576574;

            --ui-text: #c8d6e5;
            --ui-muted: #8395a7;
            --ui-accent: #48dbfb;

            --ui-green: #10ac84;
            --ui-blue: #2e86de;
            --ui-orange: #ff9f43;
            --ui-grey: #57606f;

            --ui-radius-lg: 16px;
            --ui-radius-md: 12px;
            --ui-radius-sm: 10px;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: var(--ui-font);
            background-color: #5D8AA8;
            user-select: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        /* Horizontal Line */
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 24px;
            height: 2px;
            background-color: rgba(255, 255, 255, 0.9);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 2px rgba(0,0,0,0.8);
        }

        /* Vertical Line */
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 24px;
            background-color: rgba(255, 255, 255, 0.9);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 2px rgba(0,0,0,0.8);
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 6px;
            pointer-events: none;
            font-size: 14px;
        }

        /* HOTBAR */
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .slot {
            width: 50px;
            height: 50px;
            border: 2px solid #555;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: 0.1s;
            border-radius: 4px;
        }

        .slot.active {
            border-color: white;
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .slot-color {
            width: 30px;
            height: 30px;
            border-radius: 2px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* MENU */
        #menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
                        background:
                                radial-gradient(1200px 800px at 50% 18%, rgba(72, 219, 251, 0.12), rgba(0, 0, 0, 0) 62%),
                                var(--ui-overlay);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
                        padding: 16px;
                        box-sizing: border-box;
                        backdrop-filter: blur(10px);
                        -webkit-backdrop-filter: blur(10px);
        }

        .menu-frame {
                        background:
                                linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02)),
                                var(--ui-panel);
                        width: min(620px, 94vw);
                        max-height: min(620px, 84vh);
                        border-radius: var(--ui-radius-lg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
                        box-shadow: 0 22px 70px rgba(0, 0, 0, 0.78);
                        border: 1px solid rgba(255, 255, 255, 0.10);
        }

        .tabs {
            display: flex;
                        background: rgba(255, 255, 255, 0.04);
                        border: 1px solid rgba(255, 255, 255, 0.08);
                        padding: 8px;
                        gap: 8px;
                        margin: 16px 16px 0 16px;
                        border-radius: var(--ui-radius-md);
        }

        .tab {
            flex: 1;
                        padding: 12px 10px;
            text-align: center;
            cursor: pointer;
                        color: rgba(200, 214, 229, 0.75);
                        font-weight: 800;
                        letter-spacing: 0.4px;
                        font-size: 13px;
                        transition: 0.15s;
                        border-radius: var(--ui-radius-sm);
                        user-select: none;
                        border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .tab.active {
                        background: rgba(72, 219, 251, 0.14);
                        color: white;
                        border-color: rgba(72, 219, 251, 0.35);
                        box-shadow:
                                0 10px 26px rgba(0, 0, 0, 0.28),
                                inset 0 0 0 1px rgba(72, 219, 251, 0.18);
        }

        .tab:hover {
                        background: rgba(255, 255, 255, 0.06);
        }

        .content {
                        padding: 18px 18px 0 18px;
            flex: 1;
            display: none;
                        overflow: auto;
        }

        .content.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: rgba(200, 214, 229, 0.92);
            font-weight: 600;
            font-size: 13px;
        }

        input,
        select {
            width: 100%;
            padding: 12px 12px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.10);
            color: white;
            border-radius: var(--ui-radius-sm);
            box-sizing: border-box;
            outline: none;
            font-size: 15px;
        }

        input::placeholder {
            color: rgba(200, 214, 229, 0.55);
        }

        input:focus,
        select:focus {
            border-color: rgba(72, 219, 251, 0.6);
            box-shadow: 0 0 0 3px rgba(72, 219, 251, 0.18);
            background: rgba(255, 255, 255, 0.075);
        }

        select {
            cursor: pointer;
        }

        input[type="color"] {
            cursor: pointer;
            height: 46px;
            padding: 6px;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 2px;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 1px solid #576574;
            border-radius: 4px;
        }

        .btn-row {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        button {
            flex: 1;
            padding: 13px 14px;
            border: none;
            border-radius: 14px;
            font-weight: bold;
            cursor: pointer;
            color: white;
            font-size: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: 0.15s;
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.25);
        }

            button:focus-visible {
                outline: 2px solid var(--ui-accent);
                outline-offset: 2px;
            }

        .btn-green {
            background: var(--ui-green);
        }

        .btn-green:hover {
            background: #1dd1a1;
        }

        .btn-blue {
            background: var(--ui-blue);
        }

        .btn-blue:hover {
            background: #54a0ff;
        }

        .btn-orange {
            background: var(--ui-orange);
        }

        .btn-orange:hover {
            background: #ffaf40;
        }

        #btn-close-menu {
            margin: 16px;
            text-align: center;
            background: rgba(255, 255, 255, 0.04);
            color: rgba(200, 214, 229, 0.9);
            padding: 12px;
            border-radius: 14px;
            font-weight: bold;
            cursor: pointer;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.10);
            user-select: none;
        }

        #btn-close-menu:hover {
            background: rgba(255, 255, 255, 0.07);
        }

        #status {
            color: #fbc531;
            font-size: 13px;
            margin-top: 15px;
            text-align: center;
        }

        .help-box {
            margin-top: 15px;
            padding: 14px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 14px;
            font-size: 13px;
            color: rgba(200, 214, 229, 0.92);
            line-height: 1.35;
        }

        .help-box strong {
            color: white;
        }

        #loading {
            position: absolute;
            bottom: 5px;
            right: 5px;
            color: #555;
            font-size: 10px;
        }
    </style>
</head>

<body>
    <div id="crosshair"></div>
    <!-- Chunk Loading UI - Sol √ºst k√∂≈üe, liste ≈üeklinde -->
    <div id="chunk-loading-container" style="position: fixed; top: 60px; left: 10px; display: flex; flex-direction: column; gap: 6px; z-index: 100; pointer-events: none;">
        <div id="loading-indicator" style="display: none; background: linear-gradient(135deg, rgba(30,40,50,0.92), rgba(20,30,40,0.88)); color: #4CAF50; padding: 10px 14px; border-radius: 10px; font-family: var(--ui-font); font-size: 13px; border: 1px solid rgba(76,175,80,0.3); box-shadow: 0 4px 15px rgba(0,0,0,0.3); backdrop-filter: blur(10px);">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                <div id="loading-spinner" style="width: 14px; height: 14px; border: 2px solid rgba(76,175,80,0.3); border-top-color: #4CAF50; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <span id="loading-text" style="font-weight: 500;">D√ºnya y√ºkleniyor...</span>
            </div>
            <div style="width: 160px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden;">
                <div id="loading-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 2px; transition: width 0.3s ease-out;"></div>
            </div>
        </div>
        <!-- Performans bilgisi -->
        <div id="perf-stats" style="display: none; background: rgba(30,40,50,0.85); color: #8BC34A; padding: 8px 12px; border-radius: 8px; font-size: 11px; font-family: monospace; border: 1px solid rgba(139,195,74,0.2);">
            <div>üéÆ <span id="perf-fps">--</span> FPS</div>
            <div>üì¶ <span id="perf-chunks">--</span> chunks</div>
            <div>üéØ <span id="perf-visible">--</span> g√∂r√ºn√ºr</div>
        </div>
    </div>
    <style>@keyframes spin { to { transform: rotate(360deg); } }</style>
    <div id="hud">
        FPS: <span id="fps">0</span> | Blok: <span id="blk">0</span><br>
        <span style="color:#aaa; font-size:12px">L: Kƒ±r | R: Koy | Orta: Se√ß | E: Envanter | F: Ara√ß | Shift: Ko≈ü</span>
    </div>

    <div id="hotbar"></div>

    <div id="menu-overlay" style="display: none;">
        <div class="menu-frame pause-menu">
            <div class="pause-title">‚è∏ OYUN DURAKLATILDI</div>
            
            <div class="pause-tabs">
                <div class="pause-tab active" data-tab="pause-main">OYUN</div>
                <div class="pause-tab" data-tab="pause-graphics">GRAFƒ∞K</div>
                <div class="pause-tab" data-tab="pause-multi">√áOK OYUNCULU</div>
            </div>

            <!-- Pause Main -->
            <div id="pause-main" class="pause-content active">
                <button class="pause-btn primary" id="btn-resume">‚ñ∂ DEVAM ET</button>
                <button class="pause-btn" id="btn-pause-settings">‚öô SE√áENEKLER</button>
                <button class="pause-btn" id="btn-single">üîÑ YENƒ∞DEN BA≈ûLA</button>
                <button class="pause-btn danger" id="btn-back-to-menu">üè† ANA MEN√úYE D√ñN</button>
            </div>

            <!-- Graphics Settings -->
            <div id="pause-graphics" class="pause-content">
                <div class="graphics-cards">
                    <div class="graphics-card" data-quality="low">
                        <div class="graphics-icon">‚ö°</div>
                        <div class="graphics-label">D√ú≈û√úK</div>
                        <div class="graphics-desc">Maksimum FPS</div>
                    </div>
                    <div class="graphics-card active" data-quality="medium">
                        <div class="graphics-icon">‚öñÔ∏è</div>
                        <div class="graphics-label">ORTA</div>
                        <div class="graphics-desc">Dengeli</div>
                    </div>
                    <div class="graphics-card" data-quality="high">
                        <div class="graphics-icon">‚ú®</div>
                        <div class="graphics-label">Y√úKSEK</div>
                        <div class="graphics-desc">En iyi g√∂r√ºn√ºm</div>
                    </div>
                </div>
            </div>

            <!-- Multiplayer -->
            <div id="pause-multi" class="pause-content">
                <div class="control-group">
                    <label>Oyuncu ƒ∞smi</label>
                    <input type="text" id="inp-nick" value="Oyuncu" maxlength="20">
                </div>
                <div class="control-group">
                    <label>Senin ID No</label>
                    <input type="text" id="my-id" readonly onclick="this.select()" class="id-input">
                </div>
                <div class="control-group">
                    <label>Arkada≈ü ID No</label>
                    <input type="text" id="host-id" placeholder="ID Yapƒ±≈ütƒ±r">
                </div>
                <div class="btn-row">
                    <button class="pause-btn small" id="btn-host">SUNUCU OL</button>
                    <button class="pause-btn small primary" id="btn-join">BAƒûLAN</button>
                </div>
                <p id="status"></p>
            </div>
        </div>
    </div>

    <!-- LIB (bundled for Tauri/offline) -->
    <script src="./vendor/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="./vendor/PointerLockControls.js"></script>
    <script src="./vendor/peerjs.min.js"></script>
    <script src="./js/noise.js"></script>
    
    <!-- Game Modules -->
    <script src="./js/blocks.js"></script>
    <script src="./js/biomes.js"></script>
    <script src="./js/trees.js"></script>
    <script src="./js/ores.js"></script>
    <script src="./js/crafting.js"></script>
    <script src="./js/mobs.js"></script>
    <script src="./js/performance.js"></script>
    <script src="./js/plants.js"></script>
    <script src="./js/chunk.js"></script>
    <script src="./js/vehicle.js"></script>
    <script src="./js/inventory.js"></script>
    <script src="./js/player.js"></script>
    <script src="./js/menu.js"></script>
    
    <!-- Racing Mode - FiveM To -->
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="./js/racing-vehicle.js"></script>
    <script src="./js/vehicle-manager.js"></script>
    <script src="./js/racing-ui.js"></script>
    <script src="./js/racing-multiplayer.js"></script>
    <script src="./js/racing.js"></script>

    <script>
        // --- PRE-INIT GLOBALS ---
        window.openTab = function (id) {
            document.querySelectorAll('.tab').forEach(e => e.className = 'tab');
            document.querySelectorAll('.content').forEach(e => e.className = 'content');
            document.querySelector(`[data-tab="${id}"]`).className = 'tab active';
            document.getElementById(id).className = 'content active';
        };
        
        // Setup tab listeners (CSP-safe, no inline onclick)
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.tab[data-tab]').forEach(btn => {
                btn.addEventListener('click', () => {
                    window.openTab(btn.getAttribute('data-tab'));
                });
            });
        });

        function resumeGame() {
            if (!controls) {
                alert("Hata: Oyun kontrolleri y√ºklenemedi. L√ºtfen internet baƒülantƒ±nƒ±zƒ± kontrol edip sayfayƒ± yenileyiniz.\n\nEƒüer sorun devam ederse Three.js CDN servisinde sorun olabilir.");
                return;
            }
            const overlay = document.getElementById('menu-overlay');
            if (overlay) overlay.style.display = 'none';
            
            // Canvas'a tƒ±klanƒ±nca lock yap (SecurityError yok √ß√ºnk√º ger√ßek click event i√ßinde)
            const canvas = renderer ? renderer.domElement : null;
            if (canvas && !controls.isLocked) {
                const lockOnClick = () => {
                    canvas.removeEventListener('click', lockOnClick);
                    if (!controls.isLocked) {
                        controls.lock();
                    }
                };
                canvas.addEventListener('click', lockOnClick);
            }
        }

        // --- SEED & NOISE ---
        let currentSeed = Math.floor(Math.random() * 100000);
        initSeed(currentSeed);
        console.log("Map Seed:", currentSeed);

        // --- CONFIG ---
        const GRAVITY = 25.0;
        const SPEED_WALK = 6.0;
        const SPEED_SPRINT = 10.0;
        const JUMP = 9.0;
        const P_HEIGHT = 1.6;
        const P_WIDTH = 0.6;
        const MAX_INSTANCES = 300000; 
        const MAX_PARTICLES = 2000; // Moved here for initialization order
        const MAP_SIZE = 128; // Increased map size (approx 256x256)

        // BLOCKS artƒ±k js/blocks.js'den y√ºkleniyor (65+ blok tipi)

        // --- GLOBALS ---
        let camera, scene, renderer, controls;
        let imeshes = [], instanceCounts = [];
        let dummy = new THREE.Object3D();
        let voxelData = new Map();
        let instanceKeys = [];

        let raycaster, selectedSlot = 1;
        let moveState = { f: 0, b: 0, l: 0, r: 0, s: 0, space: 0 };
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let onGround = false;

        let peer, myId, conns = [], remotePlayers = {};
        let myNick = "Oyuncu", myCol = "#00a8ff";
        
        // Graphics settings
        let graphicsQuality = 'medium'; // Default to medium
        let renderDistance = { high: 160, medium: 90, low: 40 };
        let pixelRatio = { high: 1.5, medium: 1.0, low: 0.7 };
        
        // Shader & Optimization Globals
        let animatedMaterials = [];
        
        // Particle System Globals
        let particleMesh;
        let particleData = [];

        // Audio System Globals
        let audioCtx;
        let lastStepTime = 0;

        // Vehicle system
        let vehicles = [];
        let currentVehicle = null;
        let currentVehicleSeat = -1;
        let vehicleControls = { w: 0, s: 0, a: 0, d: 0, space: 0, isDriver: false };
        let hoveredSeat = null; // { vehicle, index }

        // Timing variables (must be declared before animate)
        let last = performance.now();
        let fpsCounter = 0;
        let fpsTime = 0;
        let currentFps = 60;

        // --- SHADER & OPTIMIZATION ---
        
        const SHADER_CHUNKS = {
            pars: `
                uniform float time;
                uniform float windStrength;
            `,
            vertex: `
                // Simple wind effect
                if (windStrength > 0.0) {
                    // Calculate world position approximation for noise consistency
                    // instanceMatrix handles the transform of the instance
                    vec4 worldPos = instanceMatrix * vec4(position, 1.0);
                    
                    // Wind calculation
                    float wind = sin(time * 1.5 + worldPos.x * 0.5 + worldPos.z * 0.5) * windStrength;
                    
                    // Apply to top vertices (BoxGeometry is centered at 0,0,0, so top is y > 0)
                    if (position.y > 0.0) {
                        transformed.x += wind * 0.15;
                        transformed.z += wind * 0.15;
                        // Slight height bob for water/leaves
                        transformed.y += sin(time * 2.0 + worldPos.x) * wind * 0.05;
                    }
                }
            `
        };

        function setupMaterialOptimization(material, blockName) {
            // Animate all Leaf types and Water
            const isAnimatable = blockName.includes('Leaf') || blockName === 'Water';
            
            if (isAnimatable) {
                material.onBeforeCompile = (shader) => {
                    shader.uniforms.time = { value: 0 };
                    // Set initial value based on current settings
                    const initialWind = graphicsQuality === 'low' ? 0.0 : (graphicsQuality === 'medium' ? 0.2 : 0.5);
                    shader.uniforms.windStrength = { value: initialWind };
                    
                    material.userData.shader = shader;
                    
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <common>',
                        '#include <common>\n' + SHADER_CHUNKS.pars
                    );
                    
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        '#include <begin_vertex>\n' + SHADER_CHUNKS.vertex
                    );
                };
                
                // Add to list for updates
                animatedMaterials.push(material);
            }
        }

        // START
        init();

        function initAudio() {
            if (typeof window.AudioContext === 'undefined' && typeof window.webkitAudioContext === 'undefined') {
                console.warn("Web Audio API not supported");
                return;
            }
            
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
            } catch(e) {
                console.warn("Audio init failed:", e);
            }
        }
        
        function playSound(type) {
            if (!audioCtx) return;
            // Resume context if suspended (browser policy)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(() => {});
            }
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            
            if (type === 'step') {
                // Short noise burst for step
                // Since creating noise buffer is expensive every time, we use a simple low tone
                // or we can create a noise buffer once. Let's use a simple filtered pulse.
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'place') {
                // High pitched click
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'break') {
                // Crunchier sound
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                
                osc.start(now);
                osc.stop(now + 0.15);
            }
        }

        // Oyun y√ºklenme durumu
        let gameInitialized = false;
        
        function init() {
            // Sadece ana men√ºy√º ba≈ülat, oyun mod se√ßilince y√ºklenecek
            if (typeof initMainMenu === 'function') {
                initMainMenu();
            }
        }
        
        // Oyun motorunu ba≈ülat (mod se√ßildikten sonra √ßaƒürƒ±lƒ±r)
        function initGameEngine() {
            if (gameInitialized) return;
            gameInitialized = true;
            
            console.log('Oyun motoru ba≈ülatƒ±lƒ±yor...');
            initInventoryData();
            initThree();
            initInstancing();
            initPlantMeshes(); // Bitki sistemi
            initParticles(); // Init particles
            initAudio(); // Init audio
            initWorld();
            initUI();
            initInventoryUI();
            initPeer();
            animate();
            console.log('Oyun motoru hazƒ±r!');
        }
        
        // Global eri≈üim i√ßin
        window.initGameEngine = initGameEngine;

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Light sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 50, 120); // Extended fog range to prevent pop-in

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 300); // Extended far plane
            
            // Initialize Player Model (Hands/Weapon)
            if (typeof initPlayerModel === 'function') {
                initPlayerModel(camera);
            }
            
            // Optimized renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                stencil: false,
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio for performance
            renderer.shadowMap.enabled = false;
            document.body.appendChild(renderer.domElement);

            // Better lighting setup
            const amb = new THREE.AmbientLight(0xffffff, 0.6); // Soft ambient
            scene.add(amb);
            
            const sun = new THREE.DirectionalLight(0xfff5e6, 0.8); // Warm sunlight
            sun.position.set(50, 100, 50);
            scene.add(sun);
            
            // Hemisphere light for sky/ground color blending
            const hemi = new THREE.HemisphereLight(0x87CEEB, 0x3d5c3d, 0.4);
            scene.add(hemi);

            if (typeof THREE.PointerLockControls === 'undefined') throw new Error("PointerLockControls y√ºklenemedi.");
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
            controls.getObject().position.set(0, 30, 0); // Start higher to avoid trees
            camera.lookAt(0, 0, 0); // Look toward center

            document.addEventListener('keydown', onKey);
            document.addEventListener('keyup', onKey);
            document.addEventListener('mousedown', onMouse);
            window.addEventListener('resize', onResize);

            raycaster = new THREE.Raycaster();
            
            // Apply initial graphics settings
            applyGraphicsSettings();
        }
        
        function applyGraphicsSettings() {
            const dist = renderDistance[graphicsQuality];
            const ratio = pixelRatio[graphicsQuality];
            
            // Update fog
            scene.fog.near = dist * 0.4;
            scene.fog.far = dist;
            
            // Update camera far plane
            camera.far = dist * 2;
            camera.updateProjectionMatrix();
            
            // Update pixel ratio
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, ratio));
            
            // Update shader uniforms
            const windVal = graphicsQuality === 'low' ? 0.0 : (graphicsQuality === 'medium' ? 0.2 : 0.5);
            animatedMaterials.forEach(mat => {
                if (mat.userData.shader) {
                    mat.userData.shader.uniforms.windStrength.value = windVal;
                }
            });
            
            console.log(`Graphics: ${graphicsQuality.toUpperCase()}, Fog: ${dist}, Ratio: ${ratio}`);
        }

        // Generate procedural texture for a block
        function createBlockTexture(block, faceType = 'side') {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            // Base color (placeholder while loading)
            ctx.fillStyle = '#' + (block.col ? block.col.toString(16).padStart(6, '0') : 'FFFFFF');
            ctx.fillRect(0, 0, size, size);

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.colorSpace = THREE.SRGBColorSpace;

            // Texture Mapping from GitHub Repo
            const BASE_URL = "https://raw.githubusercontent.com/nebulimity/MoreLikeMinecraft/master/default/";
            
            const TEXTURE_MAP = {
                'Grass': { top: 'default_grass.png', side: 'default_grass_side.png', bottom: 'default_dirt.png' },
                'Dirt': 'default_dirt.png',
                'Stone': 'default_stone.png',
                'Cobble': 'default_cobble.png',
                'Brick': 'default_brick.png',
                'Sand': 'default_sand.png',
                'Snow': 'default_snow.png',
                'Water': 'default_water.png',
                'OakLog': { top: 'default_tree_top.png', side: 'default_tree.png', bottom: 'default_tree_top.png' },
                'BirchLog': { top: 'default_aspen_tree_top.png', side: 'default_aspen_tree.png', bottom: 'default_aspen_tree_top.png' },
                'SpruceLog': { top: 'default_pine_tree_top.png', side: 'default_pine_tree.png', bottom: 'default_pine_tree_top.png' },
                'JungleLog': { top: 'default_jungletree_top.png', side: 'default_jungletree.png', bottom: 'default_jungletree_top.png' },
                'Leaf': 'default_leaves.png',
                'BirchLeaf': 'default_aspen_leaves.png',
                'SpruceLeaf': 'default_leaves.png',  // No pine needles, use default leaves
                'JungleLeaf': 'default_jungleleaves.png',
                'AcaciaLeaf': 'default_acacia_leaves.png',
                'OakPlanks': 'default_wood.png',
                'BirchPlanks': 'default_aspen_wood.png',
                'SprucePlanks': 'default_pine_wood.png',
                'JunglePlanks': 'default_junglewood.png',
                'Glass': 'default_glass.png',
                'Gravel': 'default_gravel.png',
                'Clay': 'default_clay.png',
                'Obsidian': 'default_obsidian.png',
                'Lava': 'default_lava.png',
                'Ice': 'default_ice.png',
                'CoalOre': 'default_mineral_coal.png',
                'IronOre': 'default_mineral_iron.png',
                'GoldOre': 'default_mineral_gold.png',
                'DiamondOre': 'default_mineral_diamond.png',
                'CoalBlock': 'default_coal_block.png',
                'GoldBlock': 'default_gold_block.png',
                'DiamondBlock': 'default_diamond_block.png',
                'MossyCobble': 'default_mossycobble.png'
            };

            let filename = null;
            const map = TEXTURE_MAP[block.name];

            if (map) {
                if (typeof map === 'string') {
                    filename = map;
                } else if (typeof map === 'object') {
                    // Handle top/bottom/side logic
                    if (faceType === 'top') filename = map.top || map.side;
                    else if (faceType === 'bottom') filename = map.bottom || map.side;
                    else filename = map.side;
                }
            }

            if (filename) {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = BASE_URL + filename;
                img.onload = function() {
                    ctx.clearRect(0, 0, size, size);
                    
                    // Special handling for all leaf types (transparency background)
                    if (block.name.includes('Leaf')) {
                        // Use block's color as background for leaf transparency
                        const leafColor = '#' + block.col.toString(16).padStart(6, '0');
                        ctx.fillStyle = leafColor;
                        ctx.fillRect(0, 0, size, size);
                    }
                    
                    ctx.drawImage(img, 0, 0, size, size);
                    
                    // Optional: Overlay color for tinted blocks (like grass top biome tint)
                    // But for now, raw texture is best for "Exact Replica"
                    
                    texture.needsUpdate = true;
                };
                img.onerror = function() {
                    // Texture y√ºklenemezse prosed√ºrel renk kullan
                    console.warn(`Texture load failed for ${block.name}, using procedural color`);
                    drawProceduralBlock(ctx, block, faceType, size);
                    texture.needsUpdate = true;
                };
            } else {
                // Fallback to procedural if no texture mapping
                drawProceduralBlock(ctx, block, faceType, size);
            }

            return texture;
        }
        
        // Prosed√ºrel blok √ßizimi (texture yoksa veya y√ºklenemezse)
        function drawProceduralBlock(ctx, block, faceType, size) {
            const baseCol = '#' + block.col.toString(16).padStart(6, '0');
            const topCol = block.top ? '#' + block.top.toString(16).padStart(6, '0') : baseCol;
            const sideCol = block.side ? '#' + block.side.toString(16).padStart(6, '0') : baseCol;
            
            let color = baseCol;
            if (faceType === 'top') color = topCol;
            else if (faceType === 'side') color = sideCol;
            
            // Gradient fill
            const gradient = ctx.createLinearGradient(0, 0, size, size);
            gradient.addColorStop(0, topCol);
            gradient.addColorStop(1, baseCol);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            
            // Add some noise/texture for leaves
            if (block.name.includes('Leaf')) {
                ctx.globalAlpha = 0.3;
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const s = 2 + Math.random() * 4;
                    ctx.fillStyle = Math.random() > 0.5 ? '#1B5E20' : '#4CAF50';
                    ctx.fillRect(x, y, s, s);
                }
                ctx.globalAlpha = 1.0;
            }
        }

        // Global helper for inventory
        window.getBlockTextureUrl = function(block) {
            const BASE_URL = "https://raw.githubusercontent.com/nebulimity/MoreLikeMinecraft/master/default/";
            const TEXTURE_MAP = {
                'Grass': 'default_grass_side.png',
                'Dirt': 'default_dirt.png',
                'Stone': 'default_stone.png',
                'Cobble': 'default_cobble.png',
                'Brick': 'default_brick.png',
                'Sand': 'default_sand.png',
                'Snow': 'default_snow.png',
                'Water': 'default_water.png',
                'OakLog': 'default_tree.png',
                'BirchLog': 'default_aspen_tree.png',
                'SpruceLog': 'default_pine_tree.png',
                'JungleLog': 'default_jungletree.png',
                'Leaf': 'default_leaves.png',
                'BirchLeaf': 'default_aspen_leaves.png',
                'SpruceLeaf': 'default_leaves.png',  // No pine needles, use default leaves
                'JungleLeaf': 'default_jungleleaves.png',
                'AcaciaLeaf': 'default_acacia_leaves.png',
                'OakPlanks': 'default_wood.png',
                'BirchPlanks': 'default_aspen_wood.png',
                'SprucePlanks': 'default_pine_wood.png',
                'JunglePlanks': 'default_junglewood.png',
                'Glass': 'default_glass.png',
                'Gravel': 'default_gravel.png',
                'Obsidian': 'default_obsidian.png',
                'Lava': 'default_lava.png',
                'Ice': 'default_ice.png',
                'CoalOre': 'default_mineral_coal.png',
                'IronOre': 'default_mineral_iron.png',
                'GoldOre': 'default_mineral_gold.png',
                'DiamondOre': 'default_mineral_diamond.png'
            };
            
            const map = TEXTURE_MAP[block.name];
            if (map) {
                return BASE_URL + map;
            }
            return null;
        };

        function initInstancing() {
            const geo = new THREE.BoxGeometry(1, 1, 1);
            for (let i = 1; i < BLOCKS.length; i++) {
                const block = BLOCKS[i];
                if (!block) continue;
                
                // Bitki bloklarƒ± ayrƒ± sistem ile y√∂netiliyor (plants.js)
                if (block.type === BLOCK_TYPE.PLANT) {
                    imeshes[i] = null;
                    instanceCounts[i] = 0;
                    instanceKeys[i] = [];
                    continue;
                }
                
                let mat;
                
                // √áok y√ºzl√º bloklar (farklƒ± √ºst/yan texture)
                const multiTexBlocks = ['Grass', 'OakLog', 'BirchLog', 'SpruceLog', 'JungleLog', 'Cactus'];
                if (multiTexBlocks.some(n => block.name.includes(n))) {
                    const mats = [];
                    // Order: Right, Left, Top, Bottom, Front, Back
                    const sides = ['side', 'side', 'top', 'bottom', 'side', 'side'];
                    for(let j=0; j<6; j++) {
                        const tex = createBlockTexture(block, sides[j]);
                        const m = new THREE.MeshLambertMaterial({ map: tex });
                        // Transparan bloklar i√ßin
                        if (block.type === BLOCK_TYPE.TRANSPARENT) {
                            m.transparent = true;
                            m.opacity = block.opacity || 0.9;
                        }
                        // Apply shader optimization (wind effects)
                        setupMaterialOptimization(m, block.name);
                        mats.push(m);
                    }
                    mat = mats;
                } else {
                    const texture = createBlockTexture(block, 'all');
                    mat = new THREE.MeshLambertMaterial({ map: texture });
                    // Transparan bloklar i√ßin (yapraklar dahil)
                    if (block.type === BLOCK_TYPE.TRANSPARENT || block.name.includes('Leaf')) {
                        mat.transparent = true;
                        mat.alphaTest = 0.5;  // Alpha cutoff for leaves
                        mat.side = THREE.DoubleSide;  // Render both sides
                        mat.opacity = block.opacity || 1.0;
                    }
                    // Sƒ±vƒ± bloklar
                    if (block.type === BLOCK_TYPE.LIQUID) {
                        mat.transparent = true;
                        mat.opacity = 0.7;
                    }
                    // Apply shader optimization (wind effects)
                    setupMaterialOptimization(mat, block.name);
                }

                const mesh = new THREE.InstancedMesh(geo, mat, MAX_INSTANCES);
                mesh.castShadow = false; // Disable for performance
                mesh.receiveShadow = false;
                mesh.count = 0;
                // IMPORTANT: Disable frustum culling for InstancedMesh
                // Three.js can't properly cull individual instances, causing entire mesh to disappear
                mesh.frustumCulled = false;
                scene.add(mesh);
                imeshes[i] = mesh;
                instanceCounts[i] = 0;
                instanceKeys[i] = [];
            }
        }

        function setBlock(x, y, z, type, broadcast = true) {
            const key = `${x},${y},${z}`;
            const wasRemoved = voxelData.has(key) && type === 0;
            
            if (voxelData.has(key)) {
                const old = voxelData.get(key);
                if (old.type === type) return;
                
                // Spawn particles on removal
                if (type === 0) {
                    const blockInfo = BLOCKS[old.type];
                    // Use side color as approximation, or default to gray
                    const col = blockInfo ? (blockInfo.side || blockInfo.col) : 0x888888;
                    spawnParticles(x, y, z, col);
                }

                // Bitki mi normal blok mu?
                const oldBlock = BLOCKS[old.type];
                if (oldBlock && oldBlock.type === BLOCK_TYPE.PLANT) {
                    removePlantInstance(x, y, z);
                } else {
                    removeInstance(old.type, old.index);
                }
                voxelData.delete(key);
                if (broadcast) Broadcast({ t: 'blk', a: 'rm', x, y, z });
            }

            if (type > 0) {
                const block = BLOCKS[type];
                if (block && block.type === BLOCK_TYPE.PLANT) {
                    // Bitki olarak ekle
                    if (addPlantInstance(x, y, z, type)) {
                        voxelData.set(key, { type, index: -1 }); // index -1 for plants
                        if (broadcast) Broadcast({ t: 'blk', a: 'add', x, y, z, v: type });
                    }
                } else {
                    // Normal blok
                    const idx = addInstance(type, x, y, z);
                    if (idx !== -1) {
                        voxelData.set(key, { type, index: idx });
                        instanceKeys[type][idx] = key;
                        if (broadcast) Broadcast({ t: 'blk', a: 'add', x, y, z, v: type });
                    }
                }
            }
            
            // When a block is removed, check if player was standing on it and allow falling
            if (wasRemoved && controls) {
                const p = controls.getObject().position;
                // Check if player was on or near this block
                const playerFootY = p.y - P_HEIGHT;
                if (Math.abs(p.x - x) < 1.5 && Math.abs(p.z - z) < 1.5 && 
                    playerFootY >= y - 0.5 && playerFootY <= y + 1.5) {
                    // Reset onGround to allow gravity to take effect
                    onGround = false;
                }
            }
            
            document.getElementById('blk').innerText = voxelData.size;
        }

        function addInstance(type, x, y, z) {
            const mesh = imeshes[type];
            if (!mesh) return -1; // Bitki bloklarƒ± i√ßin mesh yok
            const cnt = instanceCounts[type];
            if (cnt >= MAX_INSTANCES) return -1;
            dummy.position.set(x, y, z);
            dummy.updateMatrix();
            mesh.setMatrixAt(cnt, dummy.matrix);
            mesh.instanceMatrix.needsUpdate = true;
            instanceCounts[type]++;
            mesh.count = instanceCounts[type];
            return cnt;
        }

        function removeInstance(type, idx) {
            const mesh = imeshes[type];
            if (!mesh) return; // Bitki bloklarƒ± i√ßin mesh yok
            const cnt = instanceCounts[type];
            const last = cnt - 1;

            if (idx !== last) {
                const mat = new THREE.Matrix4();
                mesh.getMatrixAt(last, mat);
                mesh.setMatrixAt(idx, mat);
                const lastKey = instanceKeys[type][last];
                instanceKeys[type][idx] = lastKey;
                const d = voxelData.get(lastKey);
                if (d) d.index = idx;
            }

            instanceCounts[type]--;
            mesh.count = instanceCounts[type];
            mesh.instanceMatrix.needsUpdate = true;
        }

        // Chunk sistemi kullanƒ±lacak mƒ±?
        var USE_CHUNK_SYSTEM = true;
        
        // G√ºvenli spawn noktasƒ± bul (aƒüa√ß g√∂vdelerinden uzak)
        function findSafeSpawnPoint() {
            const searchRadius = 10;
            let bestX = 0, bestZ = 0, bestY = 30;
            let found = false;
            
            // Merkeze yakƒ±n g√ºvenli bir nokta ara
            for (let r = 0; r <= searchRadius && !found; r++) {
                for (let dx = -r; dx <= r && !found; dx++) {
                    for (let dz = -r; dz <= r && !found; dz++) {
                        if (Math.abs(dx) !== r && Math.abs(dz) !== r) continue; // Sadece kenarlar
                        
                        const x = dx;
                        const z = dz;
                        
                        // Zemin y√ºksekliƒüini bul
                        let groundY = 0;
                        for (let y = 50; y > 0; y--) {
                            const key = `${x},${y},${z}`;
                            if (voxelData.has(key)) {
                                const block = voxelData.get(key);
                                const blockDef = BLOCKS[block.type];
                                // Sadece solid bloklar zemin olabilir
                                if (blockDef && blockDef.type === BLOCK_TYPE.SOLID) {
                                    groundY = y + 1;
                                    break;
                                }
                            }
                        }
                        
                        if (groundY < 3) continue; // √áok al√ßak
                        
                        // Ba≈ü seviyesinde ve √ºst√ºnde blok var mƒ± kontrol et
                        let isSafe = true;
                        for (let checkY = groundY; checkY < groundY + 3; checkY++) {
                            const key = `${x},${checkY},${z}`;
                            if (voxelData.has(key)) {
                                const block = voxelData.get(key);
                                const blockDef = BLOCKS[block.type];
                                if (blockDef && blockDef.type === BLOCK_TYPE.SOLID) {
                                    isSafe = false;
                                    break;
                                }
                            }
                        }
                        
                        if (isSafe && groundY > 0) {
                            bestX = x;
                            bestZ = z;
                            bestY = groundY + 1.8;
                            found = true;
                        }
                    }
                }
            }
            
            controls.getObject().position.set(bestX, bestY, bestZ);
            console.log(`[Spawn] Safe spawn found at (${bestX}, ${bestY.toFixed(1)}, ${bestZ})`);
        }
        
        function initWorld() {
            // Ground plane (water level) - covers entire map
            const waterSize = USE_CHUNK_SYSTEM ? 2000 : MAP_SIZE * 2.5;
            const waterGeo = new THREE.PlaneGeometry(waterSize, waterSize);
            const waterMat = new THREE.MeshLambertMaterial({ 
                color: 0x1E88E5, 
                transparent: true, 
                opacity: 0.6 
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0.5;
            scene.add(water);

            if (USE_CHUNK_SYSTEM) {
                // Chunk tabanlƒ± d√ºnya - progressive lazy loading
                initChunkSystem();
                console.log("[World] Chunk-based world system active");
                console.log("[World] Progressive loading enabled - chunks will load gradually");
                
                // Sadece spawn chunk'ƒ±nƒ± hemen y√ºkle (minimum ba≈ülangƒ±√ß)
                const startTime = performance.now();
                const spawnChunk = getOrCreateChunk(0, 0);
                generateChunk(spawnChunk);
                buildChunkMesh(spawnChunk);
                console.log(`[World] Spawn chunk loaded in ${(performance.now() - startTime).toFixed(0)}ms`);
                console.log("[World] Remaining chunks will load progressively...");
                
                // G√ºvenli spawn noktasƒ± bul (aƒüa√ßlarƒ±n i√ßinde deƒüil)
                findSafeSpawnPoint();
            } else {
                // Eski sistem - t√ºm haritayƒ± bir seferde olu≈ütur
                const startTime = performance.now();
                let blockCount = 0;
                let plantCount = 0;
                
                const enableCaves = graphicsQuality !== 'low';
                
                for (let x = -MAP_SIZE; x <= MAP_SIZE; x++) {
                    for (let z = -MAP_SIZE; z <= MAP_SIZE; z++) {
                        let n1 = noise2D(x / 60, z / 60); 
                        let n2 = noise2D(x / 20, z / 20) * 0.2;
                        let n = (n1 + n2);
                        let biome = noise2D(x / 150, z / 150);
                        let h = Math.floor((n + 1) * 4) + 4; 
                        
                        setBlock(x, 0, z, 63, false);
                        blockCount++;

                        for (let y = 1; y < h; y++) {
                            let type = 3;
                            
                            if (enableCaves && y > 1 && y < h - 2) {
                                const caveNoise = noise3D(x / 20, y / 20, z / 20);
                                if (caveNoise > 0.4) continue;
                            }
                            
                            if (y < h - 3) {
                                const oreRoll = Math.abs((x * 7919 + y * 6997 + z * 5653) % 10000) / 10000;
                                if (y <= 16 && oreRoll < 0.002) type = 24;
                                else if (y <= 16 && oreRoll < 0.010) type = 26;
                                else if (y <= 32 && oreRoll < 0.006) type = 23;
                                else if (y <= 64 && oreRoll < 0.015) type = 22;
                                else if (oreRoll < 0.020) type = 21;
                            }
                            
                            if (y === h - 1) {
                                if (h <= 5) type = 7;
                                else if (h > 10) type = 8;
                                else type = 1;
                            } else if (y >= h - 4) {
                                type = 2;
                            }
                            
                            setBlock(x, y, z, type, false);
                            blockCount++;
                        }
                        
                        if (h > 5 && h <= 10) {
                            const decorRoll = Math.abs((x * 3571 + z * 2953) % 1000) / 1000;
                            if (decorRoll < 0.12) {
                                setBlock(x, h, z, 44, false);
                                plantCount++;
                            } else if (decorRoll < 0.16) {
                                let flowerId = 36 + Math.floor(Math.abs((x * 123 + z * 456) % 6));
                                setBlock(x, h, z, flowerId, false);
                                plantCount++;
                            }
                        }
                        
                        if (Math.abs(x * z * 123) % 100 < 2 && h > 5 && h <= 10) {
                            let treeType = biome > 0.2 ? 'spruce' : (biome < -0.2 ? 'birch' : 'oak');
                            tree(x, h, z, treeType);
                        }
                    }
                }
                console.log(`World generated: ${blockCount} blocks, ${plantCount} plants in ${(performance.now() - startTime).toFixed(0)}ms`);
            }
            
            // Spawn a car near spawn point
            spawnVehicle(5, 10, 5);
        }

        function tree(x, y, z, type = 'oak') {
            let logId = 4; // Oak
            if (type === 'birch') logId = 11;
            if (type === 'spruce') logId = 12;

            if (type === 'spruce') {
                // Tall pine style
                const height = 6 + Math.floor(Math.random() * 3);
                for (let i = 0; i < height; i++) setBlock(x, y + i, z, logId, false);
                
                // Cone leaves
                for (let i = 2; i < height; i++) {
                    const radius = Math.floor((height - i) / 3) + 1;
                    for (let lx = x - radius; lx <= x + radius; lx++) {
                        for (let lz = z - radius; lz <= z + radius; lz++) {
                            if (Math.abs(lx - x) + Math.abs(lz - z) <= radius + 0.5) {
                                if (lx !== x || lz !== z || i === height-1) 
                                    setBlock(lx, y + i, lz, 5, false);
                            }
                        }
                    }
                }
                setBlock(x, y + height, z, 5, false);
            } else if (type === 'birch') {
                // Tall straight
                const height = 5 + Math.floor(Math.random() * 2);
                for (let i = 0; i < height; i++) setBlock(x, y + i, z, logId, false);
                
                // Leaves at top
                for (let lx = x - 2; lx <= x + 2; lx++)
                    for (let lz = z - 2; lz <= z + 2; lz++)
                        if (lx !== x || lz !== z) setBlock(lx, y + height - 1, lz, 5, false);
                setBlock(x, y + height, z, 5, false);
            } else {
                // Oak (Standard)
                const height = 4 + Math.floor(Math.random() * 2);
                for (let i = 0; i < height; i++) setBlock(x, y + i, z, logId, false);
                
                for (let lx = x - 2; lx <= x + 2; lx++)
                    for (let lz = z - 2; lz <= z + 2; lz++)
                        if (lx !== x || lz !== z) setBlock(lx, y + height - 1, lz, 5, false);
                setBlock(x, y + height, z, 5, false);
            }
        }

        // --- PARTICLE SYSTEM ---
        // particleMesh and particleData moved to globals
        // MAX_PARTICLES moved to top
        
        function initParticles() {
            const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            particleMesh = new THREE.InstancedMesh(geo, mat, MAX_PARTICLES);
            particleMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            particleMesh.count = 0;
            scene.add(particleMesh);
            
            // Initialize data pool
            for(let i=0; i<MAX_PARTICLES; i++) {
                particleData.push({
                    active: false,
                    life: 0,
                    velocity: new THREE.Vector3(),
                    position: new THREE.Vector3()
                });
            }
        }
        
        function spawnParticles(x, y, z, colorHex) {
            // Determine count based on graphics quality
            let count = graphicsQuality === 'high' ? 12 : (graphicsQuality === 'medium' ? 6 : 2);
            
            const color = new THREE.Color(colorHex || 0xffffff);
            
            for(let i=0; i<count; i++) {
                // Find free slot
                const p = particleData.find(d => !d.active);
                if(!p) break; // Pool full
                
                p.active = true;
                p.life = 1.0 + Math.random() * 0.5; // 1-1.5 seconds life
                
                // Random position within block
                p.position.set(
                    x + (Math.random() - 0.5) * 0.8,
                    y + (Math.random() - 0.5) * 0.8,
                    z + (Math.random() - 0.5) * 0.8
                );
                
                // Explosion velocity
                p.velocity.set(
                    (Math.random() - 0.5) * 4,
                    (Math.random() * 3) + 1, // Upward bias
                    (Math.random() - 0.5) * 4
                );
                
                // Set color for this instance
                particleMesh.setColorAt(particleData.indexOf(p), color);
            }
            
            particleMesh.instanceColor.needsUpdate = true;
        }
        
        function updateParticles(dt) {
            if(!particleMesh) return;
            
            let activeCount = 0;
            const dummy = new THREE.Object3D();
            
            particleData.forEach((p, i) => {
                if(!p.active) return;
                
                // Physics
                p.velocity.y -= 9.8 * dt; // Gravity
                p.position.addScaledVector(p.velocity, dt);
                
                // Floor collision (simple)
                if(p.position.y < 0) {
                    p.position.y = 0;
                    p.velocity.y *= -0.5; // Bounce
                    p.velocity.x *= 0.8; // Friction
                    p.velocity.z *= 0.8;
                }
                
                // Life
                p.life -= dt;
                if(p.life <= 0) {
                    p.active = false;
                    // Move offscreen
                    dummy.position.set(0, -1000, 0);
                    dummy.updateMatrix();
                    particleMesh.setMatrixAt(i, dummy.matrix);
                } else {
                    // Update visual
                    dummy.position.copy(p.position);
                    // Scale down as it dies
                    const scale = p.life; 
                    dummy.scale.set(scale, scale, scale);
                    dummy.updateMatrix();
                    particleMesh.setMatrixAt(i, dummy.matrix);
                    activeCount++;
                }
            });
            
            particleMesh.count = MAX_PARTICLES; // Always draw full buffer, but inactive ones are hidden
            particleMesh.instanceMatrix.needsUpdate = true;
        }

        function initUI() {
            // Hotbar is initialized by inventory.js

            // btn-close-menu artƒ±k pause men√ºde yok, g√ºvenli kontrol
            const closeBtn = document.getElementById('btn-close-menu');
            if (closeBtn) closeBtn.onclick = resumeGame;
            
            // btn-single artƒ±k pause men√ºde "yeniden ba≈üla" i√ßin
            const singleBtn = document.getElementById('btn-single');
            if (singleBtn) singleBtn.onclick = () => location.reload();
            
            // ESC key handler (WebView2/Tauri-safe)
            // Important: if pointer lock stays active, clicks target the lock element (not the menu),
            // so tabs/color picker appear "unclickable". We must unlock when showing the menu.
            const onEscape = (e) => {
                if (e.code !== 'Escape' || e.repeat) return;
                
                // If inventory is open, close it first
                if (typeof isInventoryOpen !== 'undefined' && isInventoryOpen) {
                    toggleInventory();
                    return;
                }

                const overlay = document.getElementById('menu-overlay');
                if (!overlay) return;

                const menuOpen = overlay.style.display === 'flex';
                if (menuOpen) {
                    // Menu open -> close (lock on next input)
                    resumeGame();
                    return;
                }

                // Menu closed -> show immediately and force unlock so UI can receive clicks
                overlay.style.display = 'flex';
                try {
                    if (controls && controls.isLocked && typeof controls.unlock === 'function') {
                        controls.unlock();
                    } else {
                        document.exitPointerLock();
                    }
                } catch (_) { }
            };
            window.addEventListener('keydown', onEscape, { capture: true });
            
            // Simple ESC menu handler using unlock event
            controls.addEventListener('unlock', () => {
                // Don't show menu if inventory is open
                if (typeof isInventoryOpen !== 'undefined' && isInventoryOpen) return;

                // When pointer unlocks, show menu
                const overlay = document.getElementById('menu-overlay');
                if (overlay) overlay.style.display = 'flex';
            });
            
            controls.addEventListener('lock', () => {
                // When pointer locks, hide menu
                const menuOverlay = document.getElementById('menu-overlay');
                if (menuOverlay) menuOverlay.style.display = 'none';
            });

            const nI = document.getElementById('inp-nick');
            const cI = document.getElementById('inp-color') || document.getElementById('settings-color');
            const sync = () => { 
                if (nI) myNick = nI.value; 
                if (cI) myCol = cI.value; 
                // Include ID in profile broadcast
                Broadcast({ t: 'p', i: myId, n: myNick, c: myCol }); 
            };
            if (nI) nI.addEventListener('input', sync); 
            if (cI) {
                cI.addEventListener('input', sync);
                cI.addEventListener('change', sync);
            }

            const btnSingle = document.getElementById('btn-single');
            if (btnSingle) btnSingle.onclick = () => location.reload();

            const btnHost = document.getElementById('btn-host');
            if (btnHost) btnHost.onclick = () => {
                resumeGame(); 
                const status = document.getElementById('status');
                if (status) status.innerText = "Host Aktif.";
            };
            
            const btnJoin = document.getElementById('btn-join');
            if (btnJoin) btnJoin.onclick = () => {
                const id = document.getElementById('host-id').value.trim();
                if (id && peer) {
                    const status = document.getElementById('status');
                    if (status) status.innerText = "Baƒülanƒ±yor...";
                    const conn = peer.connect(id);
                    conn.on('open', () => {
                        SetupConn(conn);
                        resumeGame();
                        if (status) status.innerText = "Baƒülandƒ±!";
                    });
                    conn.on('error', (err) => {
                        if (status) status.innerText = "Hata: " + err;
                    });
                } else {
                    const status = document.getElementById('status');
                    if (status) status.innerText = "ID giriniz!";
                }
            };
            
            // Graphics quality selector - yeni kart sistemi kullanƒ±yor, eski select yoksa atla
            const qualitySelect = document.getElementById('quality-select');
            if (qualitySelect) {
                qualitySelect.value = graphicsQuality;
                qualitySelect.onchange = (e) => {
                    graphicsQuality = e.target.value;
                    applyGraphicsSettings();
                    console.log('Graphics changed to:', graphicsQuality);
                };
            }
        }

        function selectSlot(i) {
            if (i < 1 || i > 9) return;
            selectedSlot = i;
            document.querySelectorAll('.slot').forEach(el => el.className = 'slot');
            const el = document.getElementById(`slot-${i}`);
            if(el) el.className = 'slot active';
        }



        function onKey(e) {
            const d = e.type === 'keydown';
            
            // Vehicle controls (only if in vehicle)
            if (currentVehicle) {
                switch (e.code) {
                    case 'KeyW': vehicleControls.w = d; break;
                    case 'KeyS': vehicleControls.s = d; break;
                    case 'KeyA': vehicleControls.a = d; break;
                    case 'KeyD': vehicleControls.d = d; break;
                    case 'Space': vehicleControls.space = d; break;
                    case 'KeyF': 
                        if (d) {
                            // If looking at another seat inside the same vehicle, switch to it
                            if (hoveredSeat && hoveredSeat.vehicle === currentVehicle && hoveredSeat.index !== currentVehicleSeat) {
                                switchSeat(hoveredSeat.index);
                            } else {
                                // Otherwise exit
                                exitVehicle(); 
                            }
                        }
                        break;
                }
                return; // Don't process player movement while in vehicle
            }

            // Player controls
            switch (e.code) {
                case 'KeyE': if(d) toggleInventory(); break;
                case 'KeyW': moveState.f = d; break;
                case 'KeyS': moveState.b = d; break;
                case 'KeyA': moveState.l = d; break;
                case 'KeyD': moveState.r = d; break;
                case 'Space': moveState.space = d; break;
                case 'ShiftLeft': moveState.s = d; break;
                case 'KeyF':
                    if (d) {
                        if (hoveredSeat) {
                            // Enter specific seat if looking at one
                            if (hoveredSeat.vehicle.seats[hoveredSeat.index].occupied === null) {
                                enterVehicle(hoveredSeat.vehicle, hoveredSeat.index);
                            } else {
                                // Optional: Feedback that seat is taken
                                console.log("Seat occupied");
                            }
                        } else {
                            // Fallback to nearest vehicle (auto-seat)
                            tryEnterNearbyVehicle();
                        }
                    }
                    break;
            }
            if (d && e.key >= '1' && e.key <= '9') selectSlot(parseInt(e.key));
        }



        function onMouse(e) {
            if (!controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = 8; // Maksimum 8 blok mesafe
            
            // Hem normal bloklarƒ± hem de bitkileri kontrol et
            const allMeshes = imeshes.filter(m => m);
            if (typeof plantMeshes !== 'undefined') {
                for (const id in plantMeshes) {
                    if (plantMeshes[id] && plantMeshes[id].count > 0) {
                        allMeshes.push(plantMeshes[id]);
                    }
                }
            }
            
            const hits = raycaster.intersectObjects(allMeshes);

            if (hits.length > 0) {
                const h = hits[0];
                const p = h.point.clone().add(h.face.normal.clone().multiplyScalar(0.5));
                const rmP = h.point.clone().add(h.face.normal.clone().multiplyScalar(-0.5));
                const bx = Math.round(p.x); const by = Math.round(p.y); const bz = Math.round(p.z);
                const rx = Math.round(rmP.x); const ry = Math.round(rmP.y); const rz = Math.round(rmP.z);

                if (e.button === 0) { // Left: Break
                    setBlock(rx, ry, rz, 0);
                    playSound('break');
                }
                else if (e.button === 1) { // Middle: Pick
                    const k = `${rx},${ry},${rz}`;
                    const d = voxelData.get(k);
                    if (d && d.type > 0) {
                        // Hotbar'da bu blok zaten var mƒ± kontrol et
                        let existingIdx = -1;
                        for (let i = 0; i < hotbar.length; i++) {
                            if (hotbar[i] && hotbar[i].id === d.type) {
                                existingIdx = i;
                                break;
                            }
                        }
                        
                        if (existingIdx !== -1) {
                            // Zaten varsa o slota ge√ß
                            selectSlot(existingIdx + 1);
                        } else {
                            // Yoksa se√ßili slota ekle (doƒüru format: {id, count})
                            hotbar[selectedSlot - 1] = { id: d.type, count: 1 };
                            updateHudHotbar();
                        }
                    }
                }
                else if (e.button === 2) { // Right: Place
                    const slot = hotbar[selectedSlot - 1];
                    const type = slot && slot.id ? slot.id : (typeof slot === 'number' ? slot : 0);
                    if (type > 0 && !aabbTest(controls.getObject().position, bx, by, bz)) {
                        setBlock(bx, by, bz, type);
                        playSound('place');
                    }
                }
            }
        }

        function updatePhys(dt) {
            if (currentVehicle) {
                updateVehiclePhysics(dt);
                return; // Don't update player physics when in vehicle
            }

            // Y Physics (Gravity)
            velocity.y -= GRAVITY * dt;

            // Input Movement (World Axis)
            const moveSpeed = (moveState.s ? SPEED_SPRINT : SPEED_WALK) * dt;
            const camDir = new THREE.Vector3(); controls.getDirection(camDir); camDir.y = 0; camDir.normalize();
            const sideDir = new THREE.Vector3(); sideDir.crossVectors(controls.getObject().up, camDir).normalize();

            const dx = new THREE.Vector3();
            if (moveState.f) dx.add(camDir);
            if (moveState.b) dx.sub(camDir);
            if (moveState.l) dx.add(sideDir);
            if (moveState.r) dx.sub(sideDir);
            dx.normalize().multiplyScalar(moveSpeed);

            const p = controls.getObject().position;

            // Apply X/Z Move
            p.x += dx.x; p.z += dx.z;
            
            // Footstep sounds
            if (onGround && (moveState.f || moveState.b || moveState.l || moveState.r)) {
                const now = performance.now();
                const stepInterval = moveState.s ? 300 : 500; // Faster steps when sprinting
                if (now - lastStepTime > stepInterval) {
                    playSound('step');
                    lastStepTime = now;
                }
            }
            
            if (checkCol(p)) {
                // Simple separate axis resolution basic
                p.x -= dx.x;
                if (checkCol(p)) { p.x += dx.x; p.z -= dx.z; } // Try X only
                if (checkCol(p)) { p.x -= dx.x; } // Neither worked, stay put
            }

            // Y Physics
            p.y += velocity.y * dt;
            onGround = false;
            // Check Head Collision first (Upward movement or jump)
            if (velocity.y > 0 && checkCol(p)) {
                p.y -= velocity.y * dt;
                velocity.y = 0;
            }
            // Check Foot Collision (Gravity)
            else if (checkCol(p)) {
                p.y -= velocity.y * dt;
                if (velocity.y < 0) {
                    onGround = true;
                    // Auto-jump (Bunny hopping)
                    if (moveState.space) {
                        velocity.y = JUMP;
                        onGround = false;
                    } else {
                        velocity.y = 0;
                    }
                } else {
                    velocity.y = 0;
                }
            }
            if (p.y < -30) { p.set(0, 30, 0); velocity.set(0, 0, 0); }
        }

        function checkCol(p) {
            // Precise AABB vs Block Voxel
            // Player AABB - slightly smaller to allow standing on edges better
            const edgeMargin = 0.05; // Small margin to help with edge standing
            const minX = p.x - P_WIDTH / 2 + edgeMargin; 
            const maxX = p.x + P_WIDTH / 2 - edgeMargin;
            const minY = p.y - P_HEIGHT; 
            const maxY = p.y;
            const minZ = p.z - P_WIDTH / 2 + edgeMargin; 
            const maxZ = p.z + P_WIDTH / 2 - edgeMargin;

            // Broadphase range (Increase range to catch leaves above head)
            const iMinX = Math.floor(p.x - P_WIDTH / 2 - 0.5); 
            const iMaxX = Math.floor(p.x + P_WIDTH / 2 + 0.5);
            const iMinY = Math.floor(minY - 0.5); 
            const iMaxY = Math.floor(maxY + 1.5);
            const iMinZ = Math.floor(p.z - P_WIDTH / 2 - 0.5); 
            const iMaxZ = Math.floor(p.z + P_WIDTH / 2 + 0.5);

            for (let x = iMinX; x <= iMaxX; x++) {
                for (let y = iMinY; y <= iMaxY; y++) {
                    for (let z = iMinZ; z <= iMaxZ; z++) {
                        const key = `${x},${y},${z}`;
                        if (voxelData.has(key)) {
                            const blockInfo = voxelData.get(key);
                            const blockDef = BLOCKS[blockInfo.type];
                            
                            // Skip collision for plants
                            if (blockDef && blockDef.type === BLOCK_TYPE.PLANT) continue;

                            // Block AABB (Centered at x,y,z with size 1)
                            const bMinX = x - 0.5; const bMaxX = x + 0.5;
                            const bMinY = y - 0.5; const bMaxY = y + 0.5;
                            const bMinZ = z - 0.5; const bMaxZ = z + 0.5;

                            if (minX < bMaxX && maxX > bMinX &&
                                minY < bMaxY && maxY > bMinY &&
                                minZ < bMaxZ && maxZ > bMinZ) return true;
                        }
                    }
                }
            }
            return false;
        }

        // Remove old 'check'
        function check(p) { return checkCol(p); }
        function aabbTest(p, x, y, z) {
            const r = P_WIDTH / 2;
            return (p.x + r > x - 0.5 && p.x - r < x + 0.5 && p.z + r > z - 0.5 && p.z - r < z + 0.5 && p.y > y - 0.5 && p.y - P_HEIGHT < y + 0.5);
        }



        function initPeer() {
            if (typeof Peer === 'undefined') return;
            peer = new Peer();
            peer.on('open', id => { myId = id; document.getElementById('my-id').value = id; });
            peer.on('connection', SetupConn);
        }
        function SetupConn(c) {
            conns.push(c);
            c.on('data', d => {
                if (d.t === 'm') {
                    UpdPlayer(d);
                    // Relay movement to other connections (mesh network)
                    relayToOthers(d, c);
                }
                if (d.t === 'blk') {
                    setBlock(d.x, d.y, d.z, d.a === 'add' ? d.v : 0, false);
                    // Relay block changes to others
                    relayToOthers(d, c);
                }
                if (d.t === 'p') {
                    UpdProf(d);
                    // Relay profile to others
                    relayToOthers(d, c);
                }
                if (d.t === 'v') {
                    // Vehicle position update
                    updateRemoteVehicle(d);
                    // Relay to others
                    relayToOthers(d, c);
                }
                if (d.t === 'vehicleEnter') {
                    // Remote player entered vehicle
                    handleRemoteVehicleEnter(d);
                    relayToOthers(d, c);
                }
                if (d.t === 'vehicleExit') {
                    // Remote player exited vehicle
                    handleRemoteVehicleExit(d);
                    relayToOthers(d, c);
                }
                // Handle peer list for mesh network
                if (d.t === 'peers') {
                    d.list.forEach(peerId => {
                        if (peerId !== myId && !conns.find(conn => conn.peer === peerId)) {
                            console.log('Connecting to peer:', peerId);
                            const newConn = peer.connect(peerId);
                            newConn.on('open', () => SetupConn(newConn));
                        }
                    });
                }
            });
            
            // Send current profile with ID
            c.send({ t: 'p', i: myId, n: myNick, c: myCol });
            
            // Send list of known peers for mesh networking
            const peerList = conns.map(conn => conn.peer).filter(p => p && p !== c.peer);
            if (peerList.length > 0) {
                c.send({ t: 'peers', list: peerList });
            }
            
            // Sync world to new player
            console.log('New player connected, syncing world...');
            setTimeout(() => {
                syncWorldToConnection(c);
            }, 500);
            
            console.log('Total connections:', conns.length);
        }
        
        // Relay messages to all connections except the source
        function relayToOthers(msg, sourceConn) {
            conns.forEach(c => {
                if (c !== sourceConn && c.open) {
                    try { c.send(msg); } catch(e) {}
                }
            });
        }
        
        // Send world state to a specific connection
        function syncWorldToConnection(c) {
            if (!c.open) return;
            let sent = 0;
            voxelData.forEach((data, key) => {
                const [x, y, z] = key.split(',').map(Number);
                c.send({ t: 'blk', a: 'add', x, y, z, v: data.type });
                sent++;
            });
            console.log(`Synced ${sent} blocks`);
        }
        
        function Broadcast(m) { 
            conns.forEach(c => {
                if (c.open) {
                    try { c.send(m); } catch(e) { console.warn('Send failed:', e); }
                }
            }); 
        }



        function UpdPlayer(d) {
            if (!d.i || d.i === myId) return; // Don't create player for self
            
            if (!remotePlayers[d.i]) {
                console.log('Creating remote player:', d.i);
                const g = new THREE.Group();
                
                // Body
                const m = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.9, 0.4), 
                    new THREE.MeshLambertMaterial({ color: 0xffffff })
                );
                m.position.y = 0.45; 
                g.add(m);
                
                // Head
                const h = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.4, 0.4), 
                    new THREE.MeshLambertMaterial({ color: 0xffccaa })
                );
                h.position.y = 1.1; 
                g.add(h);
                
                // Nametag sprite - properly configured
                const spriteMat = new THREE.SpriteMaterial({ 
                    transparent: true,
                    depthTest: false,
                    depthWrite: false
                });
                const s = new THREE.Sprite(spriteMat);
                s.position.y = 1.8; 
                s.scale.set(3, 0.75, 1); 
                g.add(s);
                
                scene.add(g);
                remotePlayers[d.i] = { 
                    m: g, 
                    tp: new THREE.Vector3(), 
                    tr: 0, 
                    nick: '', 
                    col: '#ffffff',
                    inVehicle: false,
                    vehicleId: null,
                    seatIndex: -1
                };
            }
            const p = remotePlayers[d.i];
            
            // Only update position if not in vehicle
            if (!p.inVehicle) {
                p.tp.set(d.x, d.y - 1.6, d.z);
            }
        }
        function UpdProf(d) {
            if (!d.i || d.i === myId) return; // Don't update self
            
            // Create player if doesn't exist
            if (!remotePlayers[d.i]) {
                UpdPlayer({ i: d.i, x: 0, y: 10, z: 0 });
            }
            
            const p = remotePlayers[d.i];
            if (!p) return;
            
            // Update body color
            try {
                p.m.children[0].material.color.set(d.c);
            } catch(e) { console.warn('Color set failed:', e); }
            
            // Store profile data
            p.nick = d.n;
            p.col = d.c;
            
            // Minecraft-style nametag
            const C = document.createElement('canvas'); 
            C.width = 512; 
            C.height = 128;
            const X = C.getContext('2d');
            
            // Clear canvas with transparency
            X.clearRect(0, 0, 512, 128);
            
            // Setup font
            X.font = "bold 36px Arial, sans-serif";
            X.textAlign = "center";
            X.textBaseline = "middle";
            const textWidth = X.measureText(d.n).width;
            
            // Draw semi-transparent black background (Minecraft style)
            const padding = 16;
            const bgX = 256 - textWidth / 2 - padding;
            const bgWidth = textWidth + padding * 2;
            const bgHeight = 50;
            const bgY = 39;
            
            // Rounded rect background
            X.fillStyle = "rgba(0, 0, 0, 0.5)";
            X.beginPath();
            X.roundRect(bgX, bgY, bgWidth, bgHeight, 4);
            X.fill();
            
            // Draw text shadow (Minecraft has dark shadow)
            X.fillStyle = "#3F3F3F";
            X.fillText(d.n, 258, 51);
            
            // Draw main text (white)
            X.fillStyle = "#FFFFFF";
            X.fillText(d.n, 256, 48);
            
            const texture = new THREE.CanvasTexture(C);
            texture.minFilter = THREE.LinearFilter;
            p.m.children[2].material.map = texture;
            p.m.children[2].material.needsUpdate = true;
        }

        // window.openTab moved to top
        function onResize() {
            camera.aspect = innerWidth / innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const t = performance.now();
            const dt = Math.min((t - last) / 1000, 0.1); // Cap delta time to prevent huge jumps
            last = t;
            
            // Performance monitoring
            if (typeof updatePerformanceStats === 'function') {
                updatePerformanceStats(dt);
            }
            
            // Game time (day/night cycle)
            if (typeof updateGameTime === 'function') {
                updateGameTime(dt);
            }
            
            // Update shader time
            const timeSec = t / 1000;
            animatedMaterials.forEach(mat => {
                if (mat.userData.shader) {
                    mat.userData.shader.uniforms.time.value = timeSec;
                }
            });
            
            // Update plants (wind animation)
            if (typeof updatePlants === 'function') {
                updatePlants(timeSec);
            }
            
            // Update chunk system (lazy loading with frustum culling)
            // Load chunks even when not locked (background loading)
            if (USE_CHUNK_SYSTEM && controls) {
                const p = controls.getObject().position;
                updateChunks(p.x, p.z, camera);
            }
            
            // Update mobs and spawning only when playing
            if (controls && controls.isLocked) {
                const p = controls.getObject().position;
                // Update mobs
                if (typeof updateMobs === 'function') {
                    updateMobs(dt, { x: p.x, y: p.y, z: p.z });
                }
                
                // Mob spawning
                if (typeof updateMobSpawning === 'function' && typeof isNightTime === 'function') {
                    updateMobSpawning({ x: p.x, y: p.y, z: p.z }, isNightTime());
                }
            }
            
            // Update particles
            updateParticles(dt);
            
            // Auto quality adjustment (every 5 seconds)
            if (typeof autoAdjustLOD === 'function' && Math.floor(t / 1000) % 5 === 0 && t % 1000 < 20) {
                autoAdjustLOD();
            }
            
            // Update performance overlay
            if (typeof updatePerformanceOverlay === 'function') {
                updatePerformanceOverlay();
            }
            
            // Update loading indicator ve performans bilgisi
            if (typeof getChunkLoadingStatus === 'function') {
                const loadStatus = getChunkLoadingStatus();
                const loadingIndicator = document.getElementById('loading-indicator');
                const loadingBar = document.getElementById('loading-bar');
                const loadingText = document.getElementById('loading-text');
                const perfStats = document.getElementById('perf-stats');
                
                // Loading indicator
                if (loadStatus.isInitialLoad || loadStatus.queueLength > 8) {
                    loadingIndicator.style.display = 'block';
                    const progress = loadStatus.isInitialLoad 
                        ? (loadStatus.loadRadius / 4) * 100 
                        : Math.max(0, 100 - (loadStatus.queueLength / 40) * 100);
                    loadingBar.style.width = Math.min(100, progress) + '%';
                    loadingText.innerText = loadStatus.isInitialLoad 
                        ? `Ba≈ülangƒ±√ß: ${loadStatus.loadedChunks} chunk` 
                        : `${loadStatus.queueLength} chunk kuyruƒüu`;
                } else {
                    loadingIndicator.style.display = 'none';
                }
                
                // Performans bilgisi (F3 ile toggle - TODO)
                if (perfStats) {
                    document.getElementById('perf-fps').innerText = currentFps;
                    document.getElementById('perf-chunks').innerText = loadStatus.loadedChunks;
                    document.getElementById('perf-visible').innerText = loadStatus.visibleChunks || '--';
                }
            }
            
            // FPS counter (update every 500ms for stability)
            fpsCounter++;
            fpsTime += dt;
            if (fpsTime >= 0.5) {
                currentFps = Math.round(fpsCounter / fpsTime);
                document.getElementById('fps').innerText = currentFps;
                fpsCounter = 0;
                fpsTime = 0;
            }
            
            if (controls.isLocked) {
                updatePhys(dt);
                
                // Update Player Model (Weapon Sway/Bob)
                if (typeof updatePlayerModel === 'function') {
                    const isMoving = moveState.f || moveState.b || moveState.l || moveState.r;
                    updatePlayerModel(dt, isMoving, moveState.s);
                }

                const p = controls.getObject().position;
                // Throttle network broadcasts (every 50ms instead of every frame)
                if (t % 50 < 20) {
                    Broadcast({ t: 'm', i: myId, x: p.x, y: p.y, z: p.z });
                }

                // Seat selection raycast (works both inside and outside vehicle)
                raycaster.setFromCamera({ x: 0, y: 0 }, camera);
                let hitSeat = null;
                
                // Collect all seat meshes from all vehicles
                const allSeatMeshes = [];
                vehicles.forEach(v => {
                    if (v.seatMeshes) {
                        v.seatMeshes.forEach(mesh => allSeatMeshes.push(mesh));
                    }
                });
                
                // If inside vehicle, ignore current seat mesh to allow looking through it? 
                // Actually we want to see other seats.
                
                const intersects = raycaster.intersectObjects(allSeatMeshes, true);
                if (intersects.length > 0 && intersects[0].distance < 5) {
                    // Find the parent group that represents the seat
                    let obj = intersects[0].object;
                    while (obj && !obj.userData.isSeat && obj.parent) {
                        obj = obj.parent;
                    }
                    
                    if (obj && obj.userData.isSeat) {
                        hitSeat = { 
                            vehicle: obj.userData.vehicle, 
                            index: obj.userData.seatIndex,
                            name: obj.userData.seatName
                        };
                    }
                }
                
                hoveredSeat = hitSeat;
                
                // Update Crosshair
                const ch = document.getElementById('crosshair');
                if (hoveredSeat) {
                    // If in vehicle, only highlight if it's a different seat in same vehicle
                    if (currentVehicle) {
                        if (hoveredSeat.vehicle === currentVehicle && hoveredSeat.index !== currentVehicleSeat) {
                            ch.style.borderColor = '#48dbfb';
                            ch.style.transform = 'translate(-50%, -50%) scale(1.5)';
                            ch.style.backgroundColor = 'rgba(72, 219, 251, 0.2)';
                        } else {
                            // Reset if looking at own seat or outside vehicle seats (though unlikely to reach outside seats)
                            ch.style.borderColor = 'rgba(255, 255, 255, 0.8)';
                            ch.style.transform = 'translate(-50%, -50%) scale(1)';
                            ch.style.backgroundColor = 'transparent';
                        }
                    } else {
                        // Outside vehicle
                        ch.style.borderColor = '#48dbfb';
                        ch.style.transform = 'translate(-50%, -50%) scale(1.5)';
                        ch.style.backgroundColor = 'rgba(72, 219, 251, 0.2)';
                    }
                } else {
                    ch.style.borderColor = 'rgba(255, 255, 255, 0.8)';
                    ch.style.transform = 'translate(-50%, -50%) scale(1)';
                    ch.style.backgroundColor = 'transparent';
                }
            }
            
            // Smooth remote player interpolation
            for (let k in remotePlayers) {
                const rp = remotePlayers[k];
                
                // If player is in vehicle, position them in their seat (sitting pose)
                if (rp.inVehicle && rp.vehicleId) {
                    const vehicle = vehicles.find(v => v.id === rp.vehicleId);
                    if (vehicle && vehicle.seats && rp.seatIndex !== -1) {
                        const seatPos = vehicle.seats[rp.seatIndex].pos.clone();
                        const upVector = new THREE.Vector3(0, 1, 0);
                        seatPos.applyAxisAngle(upVector, vehicle.rotation.y);
                        rp.m.position.copy(vehicle.position).add(seatPos);
                        rp.m.position.y -= 0.9; // Sitting position (lower than standing)
                        rp.m.visible = true; // Show player in vehicle
                        
                        // Rotate player to face forward in vehicle
                        rp.m.rotation.y = vehicle.rotation.y;
                    }
                } else {
                    // Normal movement interpolation
                    rp.m.position.lerp(rp.tp, Math.min(10 * dt, 1));
                    rp.m.visible = true;
                }
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>